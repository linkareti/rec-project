package com.linkare.rec.acquisition;

/**
 * com/linkare/rec/acquisition/MultiCastHardwarePOATie.java . Generated by the
 * IDL-to-Java compiler (portable), version "3.1" from
 * I:/Projects/REC/IdlCompile/ReC7.idl Sabado, 17 de Janeiro de 2004 19H00m GMT
 */

// if you get here in a middle of1 an acquisition call getAllSamplesUntilNow
public class MultiCastHardwarePOATie extends MultiCastHardwarePOA {

	// Constructors

	public MultiCastHardwarePOATie(final com.linkare.rec.acquisition.MultiCastHardwareOperations delegate) {
		_impl = delegate;
	}

	public MultiCastHardwarePOATie(final com.linkare.rec.acquisition.MultiCastHardwareOperations delegate,
			final org.omg.PortableServer.POA poa) {
		_impl = delegate;
		_poa = poa;
	}

	public com.linkare.rec.acquisition.MultiCastHardwareOperations _delegate() {
		return _impl;
	}

	public void _delegate(final com.linkare.rec.acquisition.MultiCastHardwareOperations delegate) {
		_impl = delegate;
	}

	@Override
	public org.omg.PortableServer.POA _default_POA() {
		if (_poa != null) {
			return _poa;
		} else {
			return super._default_POA();
		}
	}

	// that the DataClient must be regsitered...
	@Override
	public com.linkare.rec.data.metadata.HardwareInfo getHardwareInfo(final com.linkare.rec.acquisition.UserInfo user)
			throws com.linkare.rec.acquisition.NotRegistered, com.linkare.rec.acquisition.NotAuthorized {
		return _impl.getHardwareInfo(user);
	} // getHardwareInfo

	// give me a way to build a user interface
	@Override
	public com.linkare.rec.acquisition.HardwareState getHardwareState(final com.linkare.rec.acquisition.UserInfo user)
			throws com.linkare.rec.acquisition.NotRegistered, com.linkare.rec.acquisition.NotAuthorized {
		return _impl.getHardwareState(user);
	} // getHardwareState

	// How are you?
	@Override
	public void requireLock(final com.linkare.rec.acquisition.UserInfo user)
			throws com.linkare.rec.acquisition.IncorrectStateException,
			com.linkare.rec.acquisition.NotAvailableException, com.linkare.rec.acquisition.NotOwnerException,
			com.linkare.rec.acquisition.NotRegistered, com.linkare.rec.acquisition.NotAuthorized {
		_impl.requireLock(user);
	} // requireLock

	@Override
	public void registerDataClient(final com.linkare.rec.acquisition.DataClient data_client)
			throws com.linkare.rec.acquisition.NotAvailableException,
			com.linkare.rec.acquisition.MaximumClientsReached, com.linkare.rec.acquisition.NotAuthorized {
		_impl.registerDataClient(data_client);
	} // registerDataClient

	@Override
	public void configure(final com.linkare.rec.acquisition.UserInfo user,
			final com.linkare.rec.data.config.HardwareAcquisitionConfig configuration)
			throws com.linkare.rec.acquisition.IncorrectStateException,
			com.linkare.rec.acquisition.NotAvailableException, com.linkare.rec.acquisition.WrongConfigurationException,
			com.linkare.rec.acquisition.NotOwnerException, com.linkare.rec.acquisition.NotRegistered,
			com.linkare.rec.acquisition.NotAuthorized {
		_impl.configure(user, configuration);
	} // configure

	@Override
	public com.linkare.rec.acquisition.DataProducer start(final com.linkare.rec.acquisition.UserInfo user)
			throws com.linkare.rec.acquisition.IncorrectStateException,
			com.linkare.rec.acquisition.NotAvailableException, com.linkare.rec.acquisition.NotOwnerException,
			com.linkare.rec.acquisition.NotRegistered, com.linkare.rec.acquisition.NotAuthorized {
		return _impl.start(user);
	} // start

	@Override
	public com.linkare.rec.acquisition.DataProducer startOutput(final com.linkare.rec.acquisition.UserInfo user,
			final com.linkare.rec.acquisition.DataProducer data_source)
			throws com.linkare.rec.acquisition.IncorrectStateException,
			com.linkare.rec.acquisition.NotAvailableException, com.linkare.rec.acquisition.NotOwnerException,
			com.linkare.rec.acquisition.NotRegistered, com.linkare.rec.acquisition.NotAuthorized {
		return _impl.startOutput(user, data_source);
	} // startOutput

	@Override
	public void stop(final com.linkare.rec.acquisition.UserInfo user)
			throws com.linkare.rec.acquisition.IncorrectStateException,
			com.linkare.rec.acquisition.NotAvailableException, com.linkare.rec.acquisition.NotOwnerException,
			com.linkare.rec.acquisition.NotRegistered, com.linkare.rec.acquisition.NotAuthorized {
		_impl.stop(user);
	} // stop

	@Override
	public void reset(final com.linkare.rec.acquisition.UserInfo user)
			throws com.linkare.rec.acquisition.IncorrectStateException,
			com.linkare.rec.acquisition.NotAvailableException, com.linkare.rec.acquisition.NotOwnerException,
			com.linkare.rec.acquisition.NotRegistered, com.linkare.rec.acquisition.NotAuthorized {
		_impl.reset(user);
	} // reset

	@Override
	public com.linkare.rec.acquisition.DataProducer getDataProducer(final com.linkare.rec.acquisition.UserInfo user)
			throws com.linkare.rec.acquisition.IncorrectStateException,
			com.linkare.rec.acquisition.NotAvailableException, com.linkare.rec.acquisition.NotRegistered,
			com.linkare.rec.acquisition.NotAuthorized {
		return _impl.getDataProducer(user);
	} // getDataProducer

	// VTClientNameList getClientQueue(in DataClient data_client) raises
	// (NotRegistered);
	@Override
	public com.linkare.rec.acquisition.UserInfo[] getClientList(final com.linkare.rec.acquisition.UserInfo user)
			throws com.linkare.rec.acquisition.NotRegistered, com.linkare.rec.acquisition.NotAuthorized {
		return _impl.getClientList(user);
	} // getClientList

	// version 5 added suport for messages
	@Override
	public void sendMessage(final com.linkare.rec.acquisition.UserInfo userFrom, final String clientTo,
			final String message) throws com.linkare.rec.acquisition.NotRegistered,
			com.linkare.rec.acquisition.NotAuthorized {
		_impl.sendMessage(userFrom, clientTo, message);
	} // sendMessage

	private com.linkare.rec.acquisition.MultiCastHardwareOperations _impl;
	private org.omg.PortableServer.POA _poa;

} // class MultiCastHardwarePOATie
