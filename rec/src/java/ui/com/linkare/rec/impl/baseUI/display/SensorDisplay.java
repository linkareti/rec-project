/*
 * SensorDisplay.java
 *
 * Created on 29 de Maio de 2003, 8:45
 */

package com.linkare.rec.impl.baseUI.display;

import java.awt.Color;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

import javax.swing.Icon;
import javax.swing.JMenuBar;
import javax.swing.JToolBar;

import com.linkare.rec.data.acquisition.PhysicsValue;
import com.linkare.rec.data.config.HardwareAcquisitionConfig;
import com.linkare.rec.data.metadata.Scale;
import com.linkare.rec.impl.client.experiment.ExpDataModel;
import com.linkare.rec.impl.client.experiment.ExpDataModelListener;
import com.linkare.rec.impl.client.experiment.NewExpDataEvent;
/**
 *
 * @author JosÃ© Pedro Pereira - Linkare TI
 */
public class SensorDisplay extends javax.swing.JPanel implements com.linkare.rec.impl.client.experiment.ExpDataDisplay,ExpDataModelListener,java.io.Externalizable
{

    static final long serialVersionUID = -7328155533147550090L;
    
    private Icon icon=new javax.swing.ImageIcon(getClass().getResource("/com/linkare/rec/impl/baseUI/resources/sensor16.gif"));
    /** Holds value of property channelIndexDisplay. */
    private int channelIndexDisplay=0;    
    
    private String name=null;
    
    private transient ExpDataModel model;
    
    /** Creates new form SensorDisplay */
    public SensorDisplay()
    {
	initComponents();
	lblChannel.setText("Waiting for start");
	lblValue.setText("...");
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents()//GEN-BEGIN:initComponents
    {
        jScrollPane1 = new javax.swing.JScrollPane();
        jPanel1 = new javax.swing.JPanel();
        lblValue = new javax.swing.JLabel();
        lblChannel = new javax.swing.JLabel();

        setLayout(new java.awt.BorderLayout());

        setBackground(new java.awt.Color(0, 0, 0));
        setForeground(new java.awt.Color(0, 255, 0));
        jScrollPane1.setBackground(getBackground());
        jScrollPane1.setForeground(getForeground());
        jPanel1.setLayout(new java.awt.BorderLayout());

        jPanel1.setBackground(getBackground());
        jPanel1.setForeground(getForeground());
        lblValue.setBackground(getBackground());
        lblValue.setFont(new java.awt.Font("Dialog", 1, 36));
        lblValue.setForeground(getForeground());
        lblValue.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblValue.setText("25 +- 1");
        lblValue.setOpaque(true);
        jPanel1.add(lblValue, java.awt.BorderLayout.CENTER);

        lblChannel.setBackground(getBackground());
        lblChannel.setForeground(getForeground());
        lblChannel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblChannel.setText("Contagens [Cts]");
        lblChannel.setOpaque(true);
        jPanel1.add(lblChannel, java.awt.BorderLayout.NORTH);

        jScrollPane1.setViewportView(jPanel1);

        add(jScrollPane1, java.awt.BorderLayout.CENTER);

    }//GEN-END:initComponents

    /**
     * @return The Display to add to the TabPane
     */    
    public javax.swing.JComponent getDisplay()
    {
	return this;
    }    
    
    public Icon getIcon()
    {
	return icon;
    }    
    
    /** Setter for property icon.
     * @param icon New value of property icon.
     */
    public void setIcon(Icon icon)
    {
	if(icon!=null)
	    this.icon=icon;
    }
    
    public String getName()
    {
	if(name!=null)
	    return this.name;
	else
	    return "Sensor for channel " + channelIndexDisplay;
    }
    /** Setter for property name.
     * @param name New value of property name.
     */
    public void setName(String name)
    {
	if(name!=null)
	    this.name=name;
	
    }
    
    
    public void setExpDataModel(ExpDataModel model)
    {
	if(this.model!=null)
	    model.removeExpDataModelListener(this);
	
	this.model=model;
	
	if(this.model!=null)
	    this.model.addExpDataModelListener(this);
	
    }
    
    
    
    /** Getter for property channelIndexDisplay.
     * @return Value of property channelIndexDisplay.
     */
    public int getChannelIndexDisplay()
    {
	return this.channelIndexDisplay;
    }
    
    /** Setter for property channelIndexDisplay.
     * @param channelIndexDisplay New value of property channelIndexDisplay.
     */
    public void setChannelIndexDisplay(int channelIndexDisplay)
    {
	if(channelIndexDisplay>=0)
	    this.channelIndexDisplay = channelIndexDisplay;
    }
    
    public void dataModelWaiting()
    {
	
    }
    
    public void dataModelStoped()
    {
    }
    
    public void dataModelEnded()
    {
    }
    
    public void dataModelError()
    {
    }
    
    public void dataModelStarted()
    {
        if(header == null)
            headerAvailable(model.getAcquisitionConfig());
    }
    
    public void dataModelStartedNoData()
    {
        if(header == null)
            headerAvailable(model.getAcquisitionConfig());
    }    
    
    private Scale scale=null;
    private HardwareAcquisitionConfig header = null;
    private void headerAvailable(HardwareAcquisitionConfig header)
    {
        if(header == null)
            return;
        
        this.header = header;
	scale=model.getChannelConfig(channelIndexDisplay).getSelectedScale();
	String chn=model.getChannelConfig(channelIndexDisplay).getChannelName();
	String pus=scale.getPhysicsUnitSymbol();
	String multiplier=scale.getMultiplier().toString();
    
	lblChannel.setText(chn+" ["+multiplier+pus+"]");
	
    }
    
    public void newSamples(NewExpDataEvent evt)
    {
	int lastsample=evt.getSamplesEndIndex();
	PhysicsValue value=model.getValueAt(lastsample,channelIndexDisplay);
	
	lblValue.setText( value.toEngineeringNotation() );
    }
    
    public JMenuBar getMenuBar()
    {
	return null;
    }
    
    public JToolBar getToolBar()
    {
	return null;
    }
    
    /** Sets the foreground color of this component.
     * @param c the color to become this component's
     * 		foreground color; if this parameter is <code>null</code>
     * 		then this component will inherit
     * 		the foreground color of its parent
     * @see #getForeground
     * @since JDK1.0
     */
    public void setForeground(Color cout)
    {
	Color c=new Color(cout.getRGB());
	super.setForeground(c);
	if(jScrollPane1!=null)
	{
	    jScrollPane1.setForeground(getForeground());
	    jPanel1.setForeground(getForeground());
	    lblValue.setForeground(getForeground());
	    lblChannel.setForeground(getForeground());
	}
    }
    
    
     
    
    /** Sets the background color of this component.
     * <p>
     * The background color affects each component differently and the
     * parts of the component that are affected by the background color
     * may differ between operating systems.
     *
     * @param c the color to become this component's color;
     * 		if this parameter is <code>null</code>, then this
     * 		component will inherit the background color of its parent
     * @see #getBackground
     * @since JDK1.0
     * @beaninfo
     *       bound: true
     */
    public void setBackground(Color cout)
    {
	Color c=new Color(cout.getRGB());
	super.setBackground(c);
	if(jScrollPane1!=null)
	{
	    jScrollPane1.setBackground(getBackground());
	    jPanel1.setBackground(getBackground());
	    lblValue.setBackground(getBackground());
	    lblChannel.setBackground(getBackground());
	}
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblChannel;
    private javax.swing.JLabel lblValue;
    // End of variables declaration//GEN-END:variables

    
    /*public void writeObject(ObjectOutputStream os) throws IOException
    {
	os.writeObject(getForeground());
	os.writeObject(getBackground());
	os.writeObject(icon);
	os.writeUTF(getName());
	os.writeInt(getChannelIndexDisplay());
    }
    
    public void readObject(ObjectInputStream is) throws IOException
    {
	try
	{
	    setForeground((Color)is.readObject());
	}catch(ClassNotFoundException e)
	{
	}
	try
	{
	    setBackground((Color)is.readObject());
	}catch(ClassNotFoundException e)
	{
	}
	try
	{
	    setIcon((Icon)is.readObject());
	}catch(ClassNotFoundException e)
	{
	}
	setName(is.readUTF());
	setChannelIndexDisplay(is.readInt());
    }*/
    
    /** The object implements the readExternal method to restore its
     * contents by calling the methods of DataInput for primitive
     * types and readObject for objects, strings and arrays.  The
     * readExternal method must read the values in the same sequence
     * and with the same types as were written by writeExternal.
     *
     * @param in the stream to read data from in order to restore the object
     * @exception IOException if I/O errors occur
     * @exception ClassNotFoundException If the class for an object being
     *              restored cannot be found.
     */
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
    {
	try
	{
	    setForeground((Color)in.readObject());
	}catch(ClassNotFoundException e)
	{
	}
	try
	{
	    setBackground((Color)in.readObject());
	}catch(ClassNotFoundException e)
	{
	}
	try
	{
	    setIcon((Icon)in.readObject());
	}catch(ClassNotFoundException e)
	{
	}
	setName(in.readUTF());
	setChannelIndexDisplay(in.readInt());
    }
    
    /** The object implements the writeExternal method to save its contents
     * by calling the methods of DataOutput for its primitive values or
     * calling the writeObject method of ObjectOutput for objects, strings,
     * and arrays.
     *
     * @serialData Overriding methods should use this tag to describe
     *             the data layout of this Externalizable object.
     *             List the sequence of element types and, if possible,
     *             relate the element to a public/protected field and/or
     *             method of this Externalizable class.
     *
     * @param out the stream to write the object to
     * @exception IOException Includes any I/O exceptions that may occur
     */
    public void writeExternal(ObjectOutput out) throws IOException
    {
	out.writeObject(getForeground());
	out.writeObject(getBackground());
	out.writeObject(icon);
	out.writeUTF(getName());
	out.writeInt(getChannelIndexDisplay());
    }
    
}
