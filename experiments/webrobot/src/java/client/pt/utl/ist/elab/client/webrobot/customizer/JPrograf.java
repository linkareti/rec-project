/*
 * JPrografMain Version 1.1.1
 *
 * 
 * Version 1.0.0 Started on 25 de Janeiro de 2003, 15:39
 *
 *FIXED BUGS in 1.0.0
 *BUG N�1-One could't substitute a block of type 1,2,12 or 13 for one of other type, even 
 *if this was in row=2 and col=1;
 *BUG N�2-If one selected to substitute the block, and pressed ok without selecting any
 *block to substitute, there was an error(it was substituted for an empty block);
 *BUG N�3-If we had two components of type 12 or 13, one under the other, and then we deleted
 *one of them, the isAnotherAnd wasn't set to false;
 *BUG N�4-The UI configurators of esquerda, direita, frente and marchAtras, didn't update
 *correctly the totalsecs value.;
 *
 *FIXED BUGS in 1.0.1
 *BUG N�5- It was possible to add right/left components in a column of and components. It is 
 *only possible to add components to right/left of the FIRST component of the column of ANDs.
 */

/**In the version 1.1.0
 *help was added!!!
 */

/**Version 1.1.1
 *BUG N�6 - The sensor I7 was missing in the configs of ConfCompAndInt and ConfCompInt- was fixed  
 */

/**Version 1.1.2
 *The PWM block now shows the selected PWM's
 **/

/**Version 1.1.3
 *BUG N�7-When opening a file if one canceled the new command the file was still opened...
 */
/*
 * WebRobotCustomizer.java-> This is the JPrograf adaptation to the ReC
 *
 * Created on 3 de Junho de 2003, 17:53
 */

package pt.utl.ist.elab.client.webrobot.customizer;

import javax.jnlp.BasicService;
import javax.jnlp.ServiceManager;

import pt.utl.ist.elab.client.webrobot.customizer.Utils.AbsoluteConstraints;
import pt.utl.ist.elab.client.webrobot.customizer.Utils.AbsoluteLayout;
import pt.utl.ist.elab.client.webrobot.customizer.Utils.CenterFrame;
import pt.utl.ist.elab.client.webrobot.customizer.Utils.CopyPaste;
import pt.utl.ist.elab.client.webrobot.customizer.Utils.ExtensionFilter;
import pt.utl.ist.elab.client.webrobot.customizer.Utils.PrintComponent;
import pt.utl.ist.elab.client.webrobot.customizer.Utils.SaveData;
import pt.utl.ist.elab.client.webrobot.customizer.Utils.Undo;

import com.linkare.rec.data.config.HardwareAcquisitionConfig;
import com.linkare.rec.data.metadata.HardwareInfo;
import com.linkare.rec.impl.i18n.ReCResourceBundle;

/**
 * 
 * @author Andr�
 */
public class JPrograf extends javax.swing.JPanel {
	/**
	 * 
	 */
	private static final long serialVersionUID = -2937456048523484592L;
	WebRobotCustomizer customizer;

	/** Creates new form WebRobotCustomizer */
	public JPrograf(final WebRobotCustomizer customizer) {
		this.customizer = customizer;
		/**
		 * For the help system!
		 */
		/*
		 * try { java.net.URL hsURL =getClass().getResource(
		 * "/pt/utl/ist/elab/client/webrobot/customizer/help/JPrografHelpDev.hs"
		 * ); hs = new javax.help.HelpSet(null,hsURL);
		 * 
		 * } catch(javax.help.HelpSetException hse) {
		 * javax.swing.JOptionPane.showMessageDialog
		 * (this,"Problema com o help\n"
		 * +hse,"Erro!",javax.swing.JOptionPane.QUESTION_MESSAGE); } hb =
		 * hs.createHelpBroker();
		 */
		initComponents();

		/** For the dialogs... */
		JPrograf.jFrameDummy = new javax.swing.JFrame();
		new CenterFrame(JPrograf.jFrameDummy);

		// Adds the start button!
		jPanelContainer.setLayout(new AbsoluteLayout());
		jButtonProgStart = new javax.swing.JButton();
		jButtonProgStart.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/ProgStart.gif")));
		jButtonProgStart.setBorderPainted(false);
		jButtonProgStart.setMaximumSize(new java.awt.Dimension(71, 45));
		jButtonProgStart.setMinimumSize(new java.awt.Dimension(71, 45));
		jButtonProgStart.setPreferredSize(new java.awt.Dimension(71, 45));
		jButtonProgStart.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mousePressed(final java.awt.event.MouseEvent evt) {
				jButtonProgStartMousePressed(evt);
			}
		});
		jPanelContainer.add(jButtonProgStart, new AbsoluteConstraints(0, 0, -1, -1));

		// Creates the objects to undo/redo!
		JPrograf.undoBlock = new Undo();
		JPrograf.undoWiring = new Undo();

		// For undo reasons (size of the vector) I update the display twice,
		// it's not very pretty...update in the next version!
		updateDisplay(true);
		updateDisplay(true);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initComponents()// GEN-BEGIN:initComponents
	{
		jPopupMenu1 = new javax.swing.JPopupMenu();
		jMenuItemNew = new javax.swing.JMenuItem();
		jMenuItemOpen = new javax.swing.JMenuItem();
		jMenuItemSave = new javax.swing.JMenuItem();
		jMenuItemSaveAs = new javax.swing.JMenuItem();
		jMenuItemPrint = new javax.swing.JMenuItem();
		jSeparator1 = new javax.swing.JSeparator();
		jMenuItemOK = new javax.swing.JMenuItem();
		jMenuItemCancel = new javax.swing.JMenuItem();
		jSeparator3 = new javax.swing.JSeparator();
		jMenuItemUndo = new javax.swing.JMenuItem();
		jMenuItemRedo = new javax.swing.JMenuItem();
		jSeparator31 = new javax.swing.JSeparator();
		jMenuItemCopy = new javax.swing.JMenuItem();
		jMenuItemPaste = new javax.swing.JMenuItem();
		jSeparator311 = new javax.swing.JSeparator();
		jMenuItemHelp = new javax.swing.JMenuItem();
		jSeparator4 = new javax.swing.JSeparator();
		jMenuItemAbout = new javax.swing.JMenuItem();
		buttonGroupToolBar = new javax.swing.ButtonGroup();
		jFileChooserSave = new javax.swing.JFileChooser();
		jFileChooserOpen = new javax.swing.JFileChooser();
		jMenuBar = new javax.swing.JMenuBar();
		jMenuFile = new javax.swing.JMenu();
		jMenuItemNew1 = new javax.swing.JMenuItem();
		jMenuItemOpen1 = new javax.swing.JMenuItem();
		jMenuItemSave1 = new javax.swing.JMenuItem();
		jMenuItemSaveAs1 = new javax.swing.JMenuItem();
		jMenuItemPrint1 = new javax.swing.JMenuItem();
		jSeparator11 = new javax.swing.JSeparator();
		jMenuItemOK1 = new javax.swing.JMenuItem();
		jMenuItemCancel1 = new javax.swing.JMenuItem();
		jMenuEdit = new javax.swing.JMenu();
		jMenuItemUndo1 = new javax.swing.JMenuItem();
		jMenuItemRedo1 = new javax.swing.JMenuItem();
		jSeparator312 = new javax.swing.JSeparator();
		jMenuItemCopy1 = new javax.swing.JMenuItem();
		jMenuItemPaste1 = new javax.swing.JMenuItem();
		jMenuHelp = new javax.swing.JMenu();
		jMenuItemHelp1 = new javax.swing.JMenuItem();
		jSeparator41 = new javax.swing.JSeparator();
		jMenuItemAbout1 = new javax.swing.JMenuItem();
		jToolBarMain = new javax.swing.JToolBar();
		jToolBarP1 = new javax.swing.JToolBar();
		jToggleButtonCNI = new javax.swing.JToggleButton();
		jToggleButtonCB = new javax.swing.JToggleButton();
		jToggleButtonCNIAL = new javax.swing.JToggleButton();
		jToggleButtonCBAL = new javax.swing.JToggleButton();
		jToolBarP2 = new javax.swing.JToolBar();
		jToggleButtonAtribui = new javax.swing.JToggleButton();
		jToggleButtonIncDec = new javax.swing.JToggleButton();
		jToggleButtonSetReset = new javax.swing.JToggleButton();
		jToolBarP3 = new javax.swing.JToolBar();
		jToggleButtonPWM = new javax.swing.JToggleButton();
		jToggleButtonIVPWM = new javax.swing.JToggleButton();
		jToolBarP4 = new javax.swing.JToolBar();
		jToggleButtonFrente = new javax.swing.JToggleButton();
		jToggleButtonMarchAtras = new javax.swing.JToggleButton();
		jToggleButtonDireita = new javax.swing.JToggleButton();
		jToggleButtonEsquerda = new javax.swing.JToggleButton();
		jToolBarOKCancel = new javax.swing.JToolBar();
		jButton1 = new javax.swing.JButton();
		jButtonOK = new javax.swing.JButton();
		jButtonCancel = new javax.swing.JButton();
		jScrollPaneContainer = new javax.swing.JScrollPane();
		jPanelContainer = new javax.swing.JPanel();
		jPanelIndicators = new javax.swing.JPanel();
		jPanelRowCol = new javax.swing.JPanel();
		jLabelRow = new javax.swing.JLabel();
		jLabelCol = new javax.swing.JLabel();
		jLabelCompName = new javax.swing.JLabel();
		jLabelNumComps = new javax.swing.JLabel();

		jMenuItemNew.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemNew.setMnemonic('N');
		jMenuItemNew.setText("Novo");
		jMenuItemNew.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/New16.gif")));
		jMenuItemNew.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemNewActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemNew);

		jMenuItemOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemOpen.setMnemonic('O');
		jMenuItemOpen.setText("Abrir...");
		jMenuItemOpen.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Open16.gif")));
		jMenuItemOpen.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemOpenActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemOpen);

		jMenuItemSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemSave.setMnemonic('G');
		jMenuItemSave.setText("Guardar");
		jMenuItemSave.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Save16.gif")));
		jMenuItemSave.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemSaveActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemSave);

		jMenuItemSaveAs.setMnemonic('u');
		jMenuItemSaveAs.setText("Guardar como...");
		jMenuItemSaveAs.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/SaveAs16.gif")));
		jMenuItemSaveAs.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemSaveAsActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemSaveAs);

		jMenuItemPrint.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemPrint.setMnemonic('I');
		jMenuItemPrint.setText("Imprimir...");
		jMenuItemPrint.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Print16.gif")));
		jMenuItemPrint.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemPrintActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemPrint);

		jPopupMenu1.add(jSeparator1);

		jMenuItemOK.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemOK.setText("OK");
		jMenuItemOK.setToolTipText("Concluir diagrama de estados");
		jMenuItemOK.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/ok16.gif")));
		jMenuItemOK.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemOKActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemOK);

		jMenuItemCancel.setMnemonic('S');
		jMenuItemCancel.setText("Cancelar");
		jMenuItemCancel.setToolTipText("Cancelar diagrama de estados");
		jMenuItemCancel.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Cancel16.gif")));
		jMenuItemCancel.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemCancelActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemCancel);

		jPopupMenu1.add(jSeparator3);

		jMenuItemUndo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Z,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemUndo.setMnemonic('A');
		jMenuItemUndo.setText("Anular");
		jMenuItemUndo.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Undo16.gif")));
		jMenuItemUndo.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemUndoActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemUndo);

		jMenuItemRedo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Y,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemRedo.setMnemonic('R');
		jMenuItemRedo.setText("Refazer");
		jMenuItemRedo.setToolTipText("Refazer");
		jMenuItemRedo.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Redo16.gif")));
		jMenuItemRedo.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemRedoActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemRedo);

		jPopupMenu1.add(jSeparator31);

		jMenuItemCopy.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemCopy.setMnemonic('o');
		jMenuItemCopy.setText("Copiar");
		jMenuItemCopy.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Copy16.gif")));
		jMenuItemCopy.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemCopyActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemCopy);

		jMenuItemPaste.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_V,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemPaste.setMnemonic('l');
		jMenuItemPaste.setText("Colar");
		jMenuItemPaste.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Paste16.gif")));
		jMenuItemPaste.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemPasteActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemPaste);

		jPopupMenu1.add(jSeparator311);

		jMenuItemHelp.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F1, 0));
		jMenuItemHelp.setMnemonic('a');
		jMenuItemHelp.setText("T\u00f3picos de ajuda");
		jMenuItemHelp.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Help16.gif")));
		jMenuItemHelp.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemHelpActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemHelp);

		jPopupMenu1.add(jSeparator4);

		jMenuItemAbout.setMnemonic('a');
		jMenuItemAbout.setText("About...");
		jMenuItemAbout.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/About16.gif")));
		jMenuItemAbout.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemAboutActionPerformed(evt);
			}
		});

		jPopupMenu1.add(jMenuItemAbout);

		jFileChooserSave.setAcceptAllFileFilterUsed(false);
		jFileChooserSave.setCurrentDirectory(new java.io.File(System.getProperty("user.home")));
		jFileChooserSave.setDialogTitle("Guardar como...");
		jFileChooserSave.setDialogType(javax.swing.JFileChooser.SAVE_DIALOG);
		jFileChooserSave.setFileFilter(prografExtension);
		jFileChooserOpen.setAcceptAllFileFilterUsed(false);
		jFileChooserOpen.setCurrentDirectory(new java.io.File(System.getProperty("user.home")));
		jFileChooserOpen.setDialogTitle("Abrir...");
		jFileChooserOpen.setFileFilter(prografExtension);
		jMenuFile.setMnemonic('A');
		jMenuFile.setText("Arquivo");
		jMenuFile.setToolTipText("");
		jMenuItemNew1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemNew1.setMnemonic('N');
		jMenuItemNew1.setText("Novo");
		jMenuItemNew1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/New16.gif")));
		jMenuItemNew1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemNewActionPerformed(evt);
			}
		});

		jMenuFile.add(jMenuItemNew1);

		jMenuItemOpen1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemOpen1.setMnemonic('O');
		jMenuItemOpen1.setText("Abrir...");
		jMenuItemOpen1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Open16.gif")));
		jMenuItemOpen1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemOpenActionPerformed(evt);
			}
		});

		jMenuFile.add(jMenuItemOpen1);

		jMenuItemSave1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemSave1.setMnemonic('G');
		jMenuItemSave1.setText("Guardar");
		jMenuItemSave1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Save16.gif")));
		jMenuItemSave1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemSaveActionPerformed(evt);
			}
		});

		jMenuFile.add(jMenuItemSave1);

		jMenuItemSaveAs1.setMnemonic('u');
		jMenuItemSaveAs1.setText("Guardar como...");
		jMenuItemSaveAs1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/SaveAs16.gif")));
		jMenuItemSaveAs1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemSaveAsActionPerformed(evt);
			}
		});

		jMenuFile.add(jMenuItemSaveAs1);

		jMenuItemPrint1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemPrint1.setMnemonic('I');
		jMenuItemPrint1.setText("Imprimir...");
		jMenuItemPrint1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Print16.gif")));
		jMenuItemPrint1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemPrintActionPerformed(evt);
			}
		});

		jMenuFile.add(jMenuItemPrint1);

		jMenuFile.add(jSeparator11);

		jMenuItemOK1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemOK1.setText("OK");
		jMenuItemOK1.setToolTipText("Concluir diagrama de estados");
		jMenuItemOK1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/ok16.gif")));
		jMenuItemOK1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemOKActionPerformed(evt);
			}
		});

		jMenuFile.add(jMenuItemOK1);

		jMenuItemCancel1.setMnemonic('S');
		jMenuItemCancel1.setText("Cancelar");
		jMenuItemCancel1.setToolTipText("Cancelar diagrama de estados");
		jMenuItemCancel1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Cancel16.gif")));
		jMenuItemCancel1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemCancelActionPerformed(evt);
			}
		});

		jMenuFile.add(jMenuItemCancel1);

		jMenuBar.add(jMenuFile);

		jMenuEdit.setMnemonic('E');
		jMenuEdit.setText("Editar");
		jMenuItemUndo1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Z,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemUndo1.setMnemonic('A');
		jMenuItemUndo1.setText("Anular");
		jMenuItemUndo1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Undo16.gif")));
		jMenuItemUndo1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemUndoActionPerformed(evt);
			}
		});

		jMenuEdit.add(jMenuItemUndo1);

		jMenuItemRedo1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Y,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemRedo1.setMnemonic('R');
		jMenuItemRedo1.setText("Refazer");
		jMenuItemRedo1.setToolTipText("Refazer");
		jMenuItemRedo1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Redo16.gif")));
		jMenuItemRedo1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemRedoActionPerformed(evt);
			}
		});

		jMenuEdit.add(jMenuItemRedo1);

		jMenuEdit.add(jSeparator312);

		jMenuItemCopy1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemCopy1.setMnemonic('o');
		jMenuItemCopy1.setText("Copiar");
		jMenuItemCopy1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Copy16.gif")));
		jMenuItemCopy1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemCopyActionPerformed(evt);
			}
		});

		jMenuEdit.add(jMenuItemCopy1);

		jMenuItemPaste1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_V,
				java.awt.event.InputEvent.CTRL_MASK));
		jMenuItemPaste1.setMnemonic('l');
		jMenuItemPaste1.setText("Colar");
		jMenuItemPaste1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Paste16.gif")));
		jMenuItemPaste1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemPasteActionPerformed(evt);
			}
		});

		jMenuEdit.add(jMenuItemPaste1);

		jMenuBar.add(jMenuEdit);

		jMenuHelp.setMnemonic('j');
		jMenuHelp.setText("Ajuda");
		jMenuItemHelp1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F1, 0));
		jMenuItemHelp1.setMnemonic('a');
		jMenuItemHelp1.setText("T\u00f3picos de ajuda");
		jMenuItemHelp1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Help16.gif")));
		jMenuItemHelp1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemHelp1ActionPerformed(evt);
			}
		});

		jMenuHelp.add(jMenuItemHelp1);

		jMenuHelp.add(jSeparator41);

		jMenuItemAbout1.setMnemonic('a');
		jMenuItemAbout1.setText("About...");
		jMenuItemAbout1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/About16.gif")));
		jMenuItemAbout1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jMenuItemAboutActionPerformed(evt);
			}
		});

		jMenuHelp.add(jMenuItemAbout1);

		jMenuBar.add(jMenuHelp);

		setLayout(new java.awt.BorderLayout());

		jToggleButtonCNI.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/CompInt16.gif")));
		jToggleButtonCNI.setSelected(true);
		jToggleButtonCNI.setToolTipText("Comparacao de n\u00fameros inteiros");
		buttonGroupToolBar.add(jToggleButtonCNI);
		jToolBarP1.add(jToggleButtonCNI);

		jToggleButtonCB.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/CompBin16.gif")));
		jToggleButtonCB.setToolTipText("Compara\u00e7\u00e3o bin\u00e1ria");
		buttonGroupToolBar.add(jToggleButtonCB);
		jToolBarP1.add(jToggleButtonCB);

		jToggleButtonCNIAL.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/CompAndInt16.gif")));
		jToggleButtonCNIAL.setToolTipText("Compara\u00e7\u00e3o de n\u00fameros inteiros com AND l\u00f3gico");
		buttonGroupToolBar.add(jToggleButtonCNIAL);
		jToolBarP1.add(jToggleButtonCNIAL);

		jToggleButtonCBAL.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/CompAndBin16.gif")));
		jToggleButtonCBAL.setToolTipText("Compara\u00e7\u00e3o de bits com AND l\u00f3gico");
		buttonGroupToolBar.add(jToggleButtonCBAL);
		jToolBarP1.add(jToggleButtonCBAL);

		jToolBarMain.add(jToolBarP1);

		jToggleButtonAtribui.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Atribui16.gif")));
		jToggleButtonAtribui.setToolTipText("Atribui um novo valor a uma das vari\u00e1veis");
		buttonGroupToolBar.add(jToggleButtonAtribui);
		jToolBarP2.add(jToggleButtonAtribui);

		jToggleButtonIncDec.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/IncDec16.gif")));
		jToggleButtonIncDec.setToolTipText("Incrementa ou decrementa uma vari\u00e1vel");
		buttonGroupToolBar.add(jToggleButtonIncDec);
		jToolBarP2.add(jToggleButtonIncDec);

		jToggleButtonSetReset.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/SetReset16.gif")));
		jToggleButtonSetReset.setToolTipText("Activa/desactiva sa\u00edda digital");
		buttonGroupToolBar.add(jToggleButtonSetReset);
		jToolBarP2.add(jToggleButtonSetReset);

		jToolBarMain.add(jToolBarP2);

		jToggleButtonPWM.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/pwm16.gif")));
		jToggleButtonPWM.setToolTipText("Escolhe o PWM");
		buttonGroupToolBar.add(jToggleButtonPWM);
		jToolBarP3.add(jToggleButtonPWM);

		jToggleButtonIVPWM.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/ivpwm16.gif")));
		jToggleButtonIVPWM.setToolTipText("IV-PWM");
		buttonGroupToolBar.add(jToggleButtonIVPWM);
		jToolBarP3.add(jToggleButtonIVPWM);

		jToolBarMain.add(jToolBarP3);

		jToggleButtonFrente.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Frente16.gif")));
		jToggleButtonFrente.setToolTipText("Segue em frente");
		buttonGroupToolBar.add(jToggleButtonFrente);
		jToolBarP4.add(jToggleButtonFrente);

		jToggleButtonMarchAtras.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/MarchAtras16.gif")));
		jToggleButtonMarchAtras.setToolTipText("Inverte marcha");
		buttonGroupToolBar.add(jToggleButtonMarchAtras);
		jToolBarP4.add(jToggleButtonMarchAtras);

		jToggleButtonDireita.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Direita16.gif")));
		jToggleButtonDireita.setToolTipText("Roda direita");
		buttonGroupToolBar.add(jToggleButtonDireita);
		jToolBarP4.add(jToggleButtonDireita);

		jToggleButtonEsquerda.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Esquerda16.gif")));
		jToggleButtonEsquerda.setToolTipText("Roda esquerda");
		buttonGroupToolBar.add(jToggleButtonEsquerda);
		jToolBarP4.add(jToggleButtonEsquerda);

		jToolBarMain.add(jToolBarP4);

		jButton1.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Flow16.gif")));
		jButton1.setToolTipText("Default");
		jButton1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jButton1ActionPerformed(evt);
			}
		});

		jToolBarOKCancel.add(jButton1);

		jButtonOK.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/ok16.gif")));
		jButtonOK.setToolTipText("Concluir o diagrama de estados");
		jButtonOK.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jButtonOKActionPerformed(evt);
			}
		});

		jToolBarOKCancel.add(jButtonOK);

		jButtonCancel.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/pt/utl/ist/elab/client/webrobot/customizer/Icons/Cancel16.gif")));
		jButtonCancel.setToolTipText("Cancelar diagrama de estados");
		jButtonCancel.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(final java.awt.event.ActionEvent evt) {
				jButtonCancelActionPerformed(evt);
			}
		});

		jToolBarOKCancel.add(jButtonCancel);

		jToolBarMain.add(jToolBarOKCancel);

		add(jToolBarMain, java.awt.BorderLayout.NORTH);

		jScrollPaneContainer.setPreferredSize(new java.awt.Dimension(800, 600));
		jPanelContainer.setLayout(null);

		jPanelContainer.setPreferredSize(new java.awt.Dimension(5000, 5000));
		jPanelContainer.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mousePressed(final java.awt.event.MouseEvent evt) {
				jPanelContainerMousePressed(evt);
			}
		});
		jPanelContainer.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
			public void mouseMoved(final java.awt.event.MouseEvent evt) {
				jPanelContainerMouseMoved(evt);
			}
		});

		jScrollPaneContainer.setViewportView(jPanelContainer);

		add(jScrollPaneContainer, java.awt.BorderLayout.CENTER);

		jPanelIndicators.setLayout(new java.awt.BorderLayout());

		jLabelRow.setForeground(new java.awt.Color(51, 0, 102));
		jLabelRow.setText("Linha = 0 ");
		jPanelRowCol.add(jLabelRow);

		jLabelCol.setForeground(new java.awt.Color(51, 0, 102));
		jLabelCol.setText("Coluna = 0");
		jPanelRowCol.add(jLabelCol);

		jPanelIndicators.add(jPanelRowCol, java.awt.BorderLayout.WEST);

		jLabelCompName.setForeground(new java.awt.Color(51, 0, 102));
		jLabelCompName.setText("Bloco =");
		jPanelIndicators.add(jLabelCompName, java.awt.BorderLayout.CENTER);

		jLabelNumComps.setForeground(new java.awt.Color(51, 0, 102));
		jLabelNumComps.setText("N\u00ba total de blocos = 0");
		jPanelIndicators.add(jLabelNumComps, java.awt.BorderLayout.EAST);

		add(jPanelIndicators, java.awt.BorderLayout.SOUTH);

	}// GEN-END:initComponents

	private void jButton1ActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jButton1ActionPerformed
		jMenuItemNewActionPerformed(null);
		if (actionNewCanceled) {
			actionNewCanceled = false;
			return;
		}
		java.net.URL url;
		try {
			url = new java.net.URL(ReCResourceBundle.findStringOrDefault("webrobot$rec.exp.url.webrobot.4",
					"http://elab.ist.utl.pt/rec/eLab/webrobot/default.grf"));
		} catch (final java.net.MalformedURLException murle) {
			System.out.println("The url is wrong!!");
			return;
		}
		try {
			final java.net.URLConnection urlCon = url.openConnection();
			final java.io.InputStream is = urlCon.getInputStream();
			openFile(is);
		} catch (final java.io.IOException ioe) {
			javax.swing.JOptionPane.showMessageDialog(this, "N�o foi possivel abrir o ficheiro:\n" + url, "Erro!",
					javax.swing.JOptionPane.ERROR_MESSAGE);
		}
	}// GEN-LAST:event_jButton1ActionPerformed

	private void jMenuItemHelpActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemHelpActionPerformed
		jMenuItemHelp1ActionPerformed(evt);
	}// GEN-LAST:event_jMenuItemHelpActionPerformed

	private void jMenuItemHelp1ActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemHelp1ActionPerformed
		try {
			final java.net.URL url = new java.net.URL(helpURL);
			final BasicService bs = (BasicService) ServiceManager.lookup("javax.jnlp.BasicService");
			bs.showDocument(url);
		} catch (final Exception exc) {
			exc.printStackTrace();
		}
	}// GEN-LAST:event_jMenuItemHelp1ActionPerformed

	private void jButtonCancelActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jButtonCancelActionPerformed
		jMenuItemCancelActionPerformed(evt);
	}// GEN-LAST:event_jButtonCancelActionPerformed

	private void jButtonOKActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jButtonOKActionPerformed
		jMenuItemOKActionPerformed(evt);
	}// GEN-LAST:event_jButtonOKActionPerformed

	private void jPanelContainerMousePressed(final java.awt.event.MouseEvent evt) {// GEN-FIRST:event_jPanelContainerMousePressed
		if (evt.getModifiers() == java.awt.event.InputEvent.BUTTON1_MASK) {
			/**
			 * If in the Copy UI was selected the option to get the column and
			 * the row
			 */
			if (confCopy.isCopying()) {
				confCopy.setRowText("" + getRow(evt.getY()));
				confCopy.setColText("" + getColumn(evt.getX()));
				jMenuItemCopyActionPerformed(new java.awt.event.ActionEvent((Object) jPanelContainer, -3, null));
			}
			/**
			 * If in the Paste UI was selected the option to get the column and
			 * the row
			 */
			else if (confPaste.isPasting()) {
				confPaste.setRowText("" + getRow(evt.getY()));
				confPaste.setColText("" + getColumn(evt.getX()));
				jMenuItemPasteActionPerformed(new java.awt.event.ActionEvent((Object) jPanelContainer, -3, null));
			}
			/** Add the button in the selected place */
			else {
				addSelectedButton(evt.getX(), evt.getY(), 0, false, false);
			}
		} else {
			jPopupMenu1.show(this, evt.getX() + 25, evt.getY() + 25);
			/**
			 * If the selected place (with the right button of the mouse) is ok,
			 * then paste there
			 */
			/*
			 * if(isAddCompValid(evt.getX(),evt.getY(),false)) {
			 * pt.utl.ist.elab.
			 * client.webrobot.customizer.Comps.Configs.ConfPasteRightClick
			 * confPasteRightClick=new
			 * pt.utl.ist.elab.client.webrobot.customizer
			 * .Comps.Configs.ConfPasteRightClick(this,true); new
			 * CenterFrame(this,confPasteRightClick);
			 * confPasteRightClick.show(); if(confPasteRightClick.isPaste()) {
			 * rowToPaste=getRow(evt.getY()); colToPaste=getColumn(evt.getX());
			 * jMenuItemPasteActionPerformed(new
			 * java.awt.event.ActionEvent((Object
			 * )jPanelContainer,-1,null));//don't send null } }
			 */
		}
	}// GEN-LAST:event_jPanelContainerMousePressed

	private void jPanelContainerMouseMoved(final java.awt.event.MouseEvent evt) {// GEN-FIRST:event_jPanelContainerMouseMoved
		updateBottomPanel(evt.getX(), evt.getY());
	}// GEN-LAST:event_jPanelContainerMouseMoved

	private void jMenuItemAboutActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemAboutActionPerformed
		javax.swing.JOptionPane
				.showMessageDialog(
						this,
						"JPrograf � a vers�o java do programa Prograf (Programador Gr�fico)\nPrograf � propriedade da empresa IdMind-Engenharia de sistemas, Lda (info@idmind.pt)\nJPrograf-programado por Andr� Neto (L44886@alfa.ist.utl.pt)",
						"About JPrograf...", javax.swing.JOptionPane.INFORMATION_MESSAGE, new javax.swing.ImageIcon(
								getClass()
										.getResource("/pt/utl/ist/elab/client/webrobot/customizer/Icons/JPrograf.gif")));
	}// GEN-LAST:event_jMenuItemAboutActionPerformed

	private void jMenuItemPasteActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemPasteActionPerformed
		/**
		 * Paste Possibilities: 1-Paste Right(evt=null) 2-Paste
		 * Left(evt.getID()==-1) 3-Paste with right click(evt.getID()==-1)
		 * 4-Paste in selected cell(evt!=null)
		 */

		int shiftUntil;

		/**
		 * If the ID of the event is !null and different than -1(paste with
		 * right click) than we want to let the user be able to choose the
		 * pasting point!!
		 */
		if (evt != null && evt.getID() != -1) {
			new CenterFrame(this, confPaste);
			confPaste.show();
			if (confPaste.isPasting() || confPaste.isCancel()) {
				return;
			}
			rowToPaste = confPaste.getRowPaste();
			colToPaste = confPaste.getColumnPaste();
			if (matrix[rowToPaste][colToPaste] != null) {
				javax.swing.JOptionPane.showMessageDialog(this, "N�o pode colar nesta posi��o", "Erro!",
						javax.swing.JOptionPane.ERROR_MESSAGE);
				return;
			}
			if (matrix[rowToPaste - 1][colToPaste] == null) {
				javax.swing.JOptionPane.showMessageDialog(this, "N�o pode colar nesta posi��o", "Erro!",
						javax.swing.JOptionPane.WARNING_MESSAGE);
				return;
			}
		}

		/** Get the matrixs from the CopyPaste */
		matrixPaste = copyPaste.getMatrixData();
		matrixWiringPaste = copyPaste.getMatrixWiringData();

		/**
		 * If the event wasn't null then the user has choosen an empty row or
		 * column, below a column, then we want to shift the matrix like if we
		 * were introducing blocks at the right, for shiftUntil times. Of course
		 * if we are only pasting a column(or a single block), no shifting is
		 * done
		 */
		if (evt != null) {
			shiftUntil = matrixPaste[0].length - 1;
			for (int i = 1; i < shiftUntil; i++) {
				shiftColRight(rowToPaste, colToPaste, 1);
			}
		}
		/**
		 * If the event was null, means that the user has choosen paste right,
		 * or and we have to paste in the right place (probably after all the
		 * other columns...same rules of add block right or left, but for a
		 * block of matrixPaste dimension
		 */
		else {
			colToPaste = shiftColRight(rowToPaste, colToPaste - 1, matrixPaste[0].length - 1);
		}

		/**
		 * Here we copy with the elements to paste, to the right place in matrix
		 */
		for (int iRow = 1; iRow < matrixPaste.length; iRow++) {
			for (int iCol = 1; iCol < matrixPaste[0].length; iCol++) {
				matrix[rowToPaste + iRow - 1][colToPaste + iCol - 1] = matrixPaste[iRow][iCol];
				matrixWiring[rowToPaste + iRow - 1][colToPaste + iCol - 1] = matrixWiringPaste[iRow][iCol];
			}
		}

		/**
		 * Update the maxRow and maxColumn, since we added new blocks, I
		 * multiply per two just for security...maybe I lose a bit in
		 * performance, but certainly win in security!
		 */
		maxRow = maxRow + 2 * matrixPaste.length;
		maxColumn = maxColumn + 2 * matrixPaste[0].length;

		/**
		 * If the event wasn't null and different from -1, than the user has
		 * choosen to add below a column, what implies that the block above the
		 * pasting point must paint is bottom
		 */
		if (evt != null && evt.getID() != -1) {
			matrix[rowToPaste - 1][colToPaste].setPaintBottom(true);
			matrix[rowToPaste - 1][colToPaste].revalidate();
			updateDisplay(true);
			/**
			 * We always have to recopy, so we don't lose the information, this
			 * is because we don't want to point to the insert blocks, but
			 * create new ones
			 */
			jMenuItemCopyActionPerformed(null);
		} else if (evt == null) {
			/**
			 * If the evt was null than it was a paste right operation and we
			 * have to create a connection from the pasted cell to the cell in
			 * the previous column...the other code is for the case of comps of
			 * type 12 or 13
			 */
			if (matrix[rowToPaste][colToPaste - 1] != null) {
				matrix[rowToPaste][colToPaste - 1].setPaintLeft(true);
				if (matrix[rowToPaste][colToPaste] != null
						&& matrix[rowToPaste + 1][colToPaste] != null
						&& (matrix[rowToPaste][colToPaste].getTipo() == 12 || matrix[rowToPaste][colToPaste].getTipo() == 13)
						&& (matrix[rowToPaste + 1][colToPaste].getTipo() == 12 || matrix[rowToPaste + 1][colToPaste]
								.getTipo() == 13)) {
					matrixWiring[rowToPaste][colToPaste] = "<-1";
				} else {
					matrixWiring[rowToPaste][colToPaste] = "<-";
				}
				matrix[rowToPaste][colToPaste - 1].revalidate();
			}
			updateDisplay(true);
			/**
			 * We always have to recopy, so we don't lose the information, this
			 * is because we don't want to point to the inserted blocks, (having
			 * only references) but create new ones
			 */
			jMenuItemCopyActionPerformed(null);
		} else {
			updateDisplay(true);
			/**
			 * We always have to recopy, so we don't lose the information, this
			 * is because we don't want to point to the inserted blocks, but
			 * create new ones
			 */
			jMenuItemCopyActionPerformed(null);
		}
	}// GEN-LAST:event_jMenuItemPasteActionPerformed

	private void jMenuItemCopyActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemCopyActionPerformed
		/** Copy */

		/**
		 * Why tempMatrix? Because we have to create new comps, otherwise we'll
		 * keep pointing to the existing components and will lose them
		 */
		final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] tempMatrix = matrixToCopy;
		final String[][] tempMatrixWiring = matrixWiringToCopy;

		/**
		 * If the evt wasn't null(comes from the paste) and different from -2
		 * (from copy column in the block's selection options), the user wants
		 * to copy a specific column
		 */
		if (evt != null && evt.getID() != -2) {
			new CenterFrame(this, confCopy);
			confCopy.show();
			if (confCopy.isCopying() || confCopy.isCancel()) {
				return;
			}
			if (matrix[confCopy.getRowCopy()][confCopy.getColumnCopy()] == null) {
				javax.swing.JOptionPane.showMessageDialog(this,
						"A coluna e a linha escolhida, n�o permitem que se efectue esta opera��o!", "Erro!",
						javax.swing.JOptionPane.ERROR_MESSAGE);
				return;
			}
		}
		/**
		 * As said before the event=null, implies that it comes from paste, to
		 * recopy the elements so we don't lose them. Meaning if we just recopy
		 * the same matrix, we'll move the components that where previous
		 * pasted, because it would copy only the reference to the objects, and
		 * not the objects ...
		 */
		else if (evt == null) {
			for (int iRow = 0; iRow < matrixToCopy.length; iRow++) {
				for (int iCol = 0; iCol < matrixToCopy[0].length; iCol++) {
					if (matrixToCopy[iRow][iCol] != null) {
						pt.utl.ist.elab.client.webrobot.customizer.Comps.Block copyBlock = createNewBlock(
								matrixToCopy[iRow][iCol].getTipo(), matrixToCopy[iRow][iCol].getDataModel());
						addCompEvents(copyBlock);
						/**
						 * If the matrix wasn't null for this cell, and the
						 * returned block is null, then it was a connection
						 * block(horLine) for sure
						 */
						if (copyBlock == null) {
							copyBlock = new pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine();
						}
						tempMatrix[iRow][iCol] = copyBlock;
					} else {
						tempMatrix[iRow][iCol] = null;
					}
					/** Copies the connection matrix contents */
					tempMatrixWiring[iRow][iCol] = matrixWiringToCopy[iRow][iCol];
				}
			}
			/**
			 * The new copy matrix was created with "fresh" components and it's
			 * ready for another paste!!
			 */
			copyPaste.addData(tempMatrix);
			copyPaste.addData(tempMatrixWiring);
			return;
		}
		/**
		 * If the event wasn't null we have two options: it came from copy colum
		 * in the block options evt.getID()==-2, or it came from the copy UI If
		 * it came from the copy UI, one must actualize the GLOBAL variables
		 * rowToCopyIni and colToCopyIni
		 */
		if (evt != null) {
			if (evt.getID() != -2) {
				rowToCopyIni = confCopy.getRowCopy();
				colToCopyIni = confCopy.getColumnCopy();
			}
		}

		/**
		 * We want to copy all the links that this column has in all the rows
		 * BELOW the selected one!!!
		 */
		colToCopyEnd = getMaxAllowedColumn(rowToCopyIni, colToCopyIni);
		/**
		 * Get the last non null row, we don't want to copy until maxRow(which
		 * is almost for sure different from the last non null row...I do this
		 * for matrix dimension problems
		 */
		rowToCopyEnd = getLastNonNullRow();
		/** Security check */
		if (rowToCopyIni == 0) {
			return;
		}

		/**
		 * Creates two new matrixs with correct dimensions, then the neading of
		 * the accuracy in the last row (getLastNonNullRow), remember that
		 * maxRow is only for performance reasons so that we don't have to huge
		 * cycles ,but is only an approximate number (always bigger than the
		 * real maximum row populated
		 */
		matrixToCopy = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[rowToCopyEnd - rowToCopyIni + 1][colToCopyEnd
				- colToCopyIni + 1];
		matrixWiringToCopy = new String[rowToCopyEnd - rowToCopyIni + 1][colToCopyEnd - colToCopyIni + 1];
		int rowCp = 1;
		int colCp = 1;

		/** Copy the matrix and create new block...already explained before */
		for (int iRow = rowToCopyIni; iRow < rowToCopyEnd; iRow++) {
			colCp = 1;
			for (int iCol = colToCopyIni; iCol < colToCopyEnd; iCol++) {
				if (matrix[iRow][iCol] != null) {
					pt.utl.ist.elab.client.webrobot.customizer.Comps.Block copyBlock = createNewBlock(
							matrix[iRow][iCol].getTipo(), matrix[iRow][iCol].getDataModel());
					addCompEvents(copyBlock);
					if (copyBlock == null) {
						copyBlock = new pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine();
					}
					matrixToCopy[rowCp][colCp] = copyBlock;
				} else {
					matrixToCopy[rowCp][colCp] = null;
				}
				matrixWiringToCopy[rowCp][colCp] = matrixWiring[iRow][iCol];
				colCp++;
				/**
				 * if this column, has another one at its left, I don't want to
				 * copy the connections to this column!!
				 */
				if (colCp == 1) {
					matrixWiringToCopy[rowCp][colCp] = null;
				}
				/**
				 * Don't copy connections that are at the right of the starting
				 * block in the column selected to copy
				 */
				if (iRow == rowToCopyIni) {
					break;
				}
			}
			rowCp++;
		}
		copyPaste.addData(matrixToCopy);
		copyPaste.addData(matrixWiringToCopy);
	}// GEN-LAST:event_jMenuItemCopyActionPerformed

	private void jMenuItemRedoActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemRedoActionPerformed
		if (JPrograf.undoBlock.isRedoable()) {
			final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] matrixUndo = (pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][]) JPrograf.undoBlock
					.redoElement();
			final String[][] matrixUndoWiring = (String[][]) JPrograf.undoWiring.redoElement();
			if (matrixUndo == null) {
				return;
			}
			for (int iRow = 0; iRow < matrixUndo.length; iRow++) {
				for (int iCol = 0; iCol < matrixUndo[iRow].length; iCol++) {
					matrix[iRow][iCol] = matrixUndo[iRow][iCol];
					matrixWiring[iRow][iCol] = matrixUndoWiring[iRow][iCol];
				}
			}
			updateDisplay(false);
		}
	}// GEN-LAST:event_jMenuItemRedoActionPerformed

	private void jMenuItemUndoActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemUndoActionPerformed
		if (JPrograf.undoBlock.isUndoable()) {
			final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] matrixUndo = (pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][]) JPrograf.undoBlock
					.undoElement();
			final String[][] matrixUndoWiring = (String[][]) JPrograf.undoWiring.undoElement();
			if (matrixUndo == null) {
				return;
			}
			for (int iRow = 0; iRow < matrixUndo.length; iRow++) {
				for (int iCol = 0; iCol < matrixUndo[iRow].length; iCol++) {
					matrix[iRow][iCol] = matrixUndo[iRow][iCol];
					matrixWiring[iRow][iCol] = matrixUndoWiring[iRow][iCol];
				}
			}
			updateDisplay(false);
		}
	}// GEN-LAST:event_jMenuItemUndoActionPerformed

	private void jMenuItemCancelActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemCancelActionPerformed
		int exit = javax.swing.JOptionPane.NO_OPTION;
		if (haveBeenChanges) {
			exit = javax.swing.JOptionPane.showOptionDialog(this, "Existem altera��es n�o gravadas!\nSair?", "Sair",
					javax.swing.JOptionPane.YES_NO_OPTION, javax.swing.JOptionPane.QUESTION_MESSAGE, null, YES_NO_OPTS,
					null);
			if (exit == javax.swing.JOptionPane.YES_OPTION) {
				customizer.fireICustomizerListenerCanceled();
			} else {
			}
		} else {
			customizer.fireICustomizerListenerCanceled();
		}
	}// GEN-LAST:event_jMenuItemCancelActionPerformed

	private void jMenuItemPrintActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemPrintActionPerformed
		new PrintComponent(jPanelContainer);
	}// GEN-LAST:event_jMenuItemPrintActionPerformed

	private void jMenuItemOKActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemOKActionPerformed
		final SaveData sd = new SaveData(null, matrix, confInOut, ivpwm, maxRow, maxColumn);
		final String flowChart = sd.getSavedString();
		acqConfig.setTotalSamples(hardwareInfo.getSamplingScale().getMaxSamples());
		acqConfig.getSelectedHardwareParameter("FlowChart").setParameterValue(flowChart);
		acqConfig.setSelectedFrequency(hardwareInfo.getSelectedFrequency());
		customizer.fireICustomizerListenerDone();
	}// GEN-LAST:event_jMenuItemOKActionPerformed

	private void jMenuItemSaveAsActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemSaveAsActionPerformed
		final int returnValue = jFileChooserSave.showSaveDialog(this);
		if (returnValue == jFileChooserSave.APPROVE_OPTION) {
			haveBeenChanges = false;
			if (jFileChooserSave.getFileFilter().equals(prografExtension)) {
				extension = prografExtension.getExtension();
			}
			String path = jFileChooserSave.getSelectedFile().getPath();
			if (path.endsWith(".grf")) {
				path = path.substring(0, path.length() - 4);
			}
			saveFile = new java.io.File(path + "." + extension);
			new SaveData(saveFile, matrix, confInOut, ivpwm, maxRow, maxColumn);
		}
	}// GEN-LAST:event_jMenuItemSaveAsActionPerformed

	private void jMenuItemSaveActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemSaveActionPerformed
		if (saveFile == null) {
			jMenuItemSaveAsActionPerformed(evt);
		} else {
			haveBeenChanges = false;
			new SaveData(saveFile, matrix, confInOut, ivpwm, maxRow, maxColumn);
		}
	}// GEN-LAST:event_jMenuItemSaveActionPerformed

	private void jMenuItemOpenActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemOpenActionPerformed
		final int returnValue = jFileChooserOpen.showOpenDialog(this);
		if (returnValue == jFileChooserOpen.APPROVE_OPTION) {
			jMenuItemNewActionPerformed(null);
			if (actionNewCanceled) {
				actionNewCanceled = false;
				return;
			}
			if (jFileChooserOpen.getFileFilter().equals(prografExtension)) {
				extension = prografExtension.getExtension();
			}
			final String path = jFileChooserOpen.getSelectedFile().getPath();
			final java.io.File openFile = new java.io.File(path);
			try {
				openFile(openFile);
			} catch (final java.io.IOException ioe) {
				javax.swing.JOptionPane.showMessageDialog(this,
						"N�o foi possivel abrir o ficheiro:\n" + openFile.getPath(), "Erro!",
						javax.swing.JOptionPane.ERROR_MESSAGE);
			}
			saveFile = openFile;
			haveBeenChanges = false;
		}
	}// GEN-LAST:event_jMenuItemOpenActionPerformed

	private boolean actionNewCanceled = false;

	private void jMenuItemNewActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jMenuItemNewActionPerformed
		int save = javax.swing.JOptionPane.NO_OPTION;
		if (haveBeenChanges) {
			save = javax.swing.JOptionPane.showOptionDialog(this, "Deseja gravar altera��es?", "Novo",
					javax.swing.JOptionPane.YES_NO_CANCEL_OPTION, javax.swing.JOptionPane.QUESTION_MESSAGE, null,
					YES_NO_CANCEL_OPTS, null);
		}
		if (save == javax.swing.JOptionPane.YES_OPTION) {
			jMenuItemSaveAsActionPerformed(null);
			return;
		}
		if (save == javax.swing.JOptionPane.CANCEL_OPTION) {
			actionNewCanceled = true;
			return;
		}
		saveFile = null;
		haveBeenChanges = false;
		resetMatrix();
		clearDisplay();
	}// GEN-LAST:event_jMenuItemNewActionPerformed

	private void jButtonProgStartMousePressed(final java.awt.event.MouseEvent evt) {
		confInOut = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.ConfInOut(JPrograf.jFrameDummy, true,
				JPrograf.modelConfInOut);
		new CenterFrame(this, confInOut);
		confInOut.show();
	}

	/**
	 * If the mouse is moved over the JPanel, and it passes over a component, we
	 * must get the event from this component, this is why I've added a mouse
	 * moved event to the components
	 */
	private void compMouseMoved(final java.awt.event.MouseEvent evt) {
		final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block comp = (pt.utl.ist.elab.client.webrobot.customizer.Comps.Block) evt
				.getSource();
		updateBottomPanel(comp.getX(), comp.getY());
	}

	/** If one clicks over a block */
	private void compMousePressed(final java.awt.event.MouseEvent evt) {
		final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block comp = (pt.utl.ist.elab.client.webrobot.customizer.Comps.Block) evt
				.getSource();
		final int posX = comp.getX();
		final int posY = comp.getY();
		int row = getRow(posY);
		final int col = getColumn(posX);

		if (evt.getModifiers() == java.awt.event.InputEvent.BUTTON1_MASK) {
			/**
			 * If the user had selected to choose with mouse the copy or paste
			 * location then return this component location
			 */
			if (confCopy.isCopying()) {
				confCopy.setRowText("" + row);
				confCopy.setColText("" + col);
				jMenuItemCopyActionPerformed(new java.awt.event.ActionEvent((Object) jPanelContainer, -3, null));
				return;
			}
			/**
			 * If the user had selected to choose with mouse the copy or paste
			 * location then return this component location
			 */
			else if (confPaste.isPasting()) {
				confPaste.setRowText("" + row);
				confPaste.setColText("" + col);
				jMenuItemPasteActionPerformed(new java.awt.event.ActionEvent((Object) jPanelContainer, -3, null));
				return;
			}

			/**
			 * The user with a left click can do: 0-cancel 1-edit the component
			 * 2-add a component below the selected one 3-remove a single block
			 * 4-substitute a block 5-copy the column (starting at the selected
			 * block) 6-del column 7-del column
			 */
			new CenterFrame(this, editSubDel);
			editSubDel.show();
			if (editSubDel.getSelection() == 0) {
				return;
			}
			if (editSubDel.getSelection() == 1) {
				comp.edit(JPrograf.jFrameDummy);
			} else if (editSubDel.getSelection() == 2) {
				addSelectedButton(posX, posY + COL_HEIGHT, 0, false, false);
			}

			else if (editSubDel.getSelection() == 3) {
				delBlock(row, col, false);
				/**
				 * I need to update the horlines, since a shift up, can delete
				 * horlines that aren't supposed to be deleted...but horlines
				 * are the only block that can be deleted accidentally
				 */
				updateHorLines();
				updateDisplay(true);
			}

			else if (editSubDel.getSelection() == 4) {
				/**
				 * If one wants to substitute a block of type 1,2,12 or 13, and
				 * has a connection to the block at his left, then it can only
				 * be substituted by one of type 1,2,12 or 13
				 */
				if ((isConnectionBlock(matrix[row][col]) && (matrix[row + 1][col] != null
						|| matrixWiring[row][col] == "<-" || matrixWiring[row][col + 1] == "<-"))) {
					subBlock = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.SubBlock(
							JPrograf.jFrameDummy, true, comp.getTipo(), true);
				} else {
					subBlock = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.SubBlock(
							JPrograf.jFrameDummy, true, comp.getTipo(), false);
				}
				/**
				 * subBlock.setSubTipo(-1), for the case of one selects ok
				 * without selecting any component, which is the same of
				 * canceling
				 */
				subBlock.setSubTipo(-1);
				new CenterFrame(this, subBlock);
				subBlock.show();
				if (subBlock.getSubTipo() == -1) {
					return;
				}
				matrix[row][col] = null;
				addSelectedButton(posX, posY, subBlock.getSubTipo(), true, false);
			}

			else if (editSubDel.getSelection() == 5) {
				/**
				 * Set the global variables rowToCopyIni and colToCopyIni with
				 * the component coordinates
				 */
				rowToCopyIni = row;
				colToCopyIni = col;
				final java.awt.event.ActionEvent aEvt2 = new java.awt.event.ActionEvent((Object) jPanelContainer, -2,
						null);
				jMenuItemCopyActionPerformed(aEvt2);// aEvt2 just to send not
				// null...
			}

			else if (editSubDel.getSelection() == 6 || editSubDel.getSelection() == 7) {
				shiftedColsInDel = false;
				boolean firstCon = false;
				boolean hasAHorLine = false;
				/**
				 * If this component is connected with one at his right, sign it
				 */
				if (matrixWiring[row][col + 1] != null) {
					firstCon = true;
				}
				/**
				 * If this component is connected with an horLine at his right,
				 * sign it
				 */
				if (matrix[row][col + 1] != null && isHorLine(row, col + 1)) {
					firstCon = false;
					hasAHorLine = true;
					row = row + 1;
				}
				/**
				 * Since this component has a connection with a component at its
				 * right, clear this column (while(matrix[row][col]!=null) and
				 * stop when arrive to the block at his right(shifted in the
				 * delBlock method
				 */
				if (firstCon) {
					while (matrix[row][col] != null) {
						if (shiftedColsInDel) {
							break;
						}
						delBlock(row, col, true);
					}
				}
				/**
				 * Clear all blocks of this row, and all connections that those
				 * have. If the component has an horLine connection, start at
				 * row+1!
				 */
				else {
					final int maxAllowedCol = getMaxAllowedColumn(row, col);
					for (int iCol = col; iCol < maxAllowedCol; iCol++) {
						for (int iRow = row; iRow < maxRow + 1; iRow++) {
							delBlock(row, col, true);
						}
					}
				}
				/**
				 * Since I've cleaned all components until row+1, I have to
				 * delete the original block.
				 */
				if (hasAHorLine) {
					delBlock(row - 1, col, true);
				}
				updateDisplay(true);
			}

			return;
		}

		else {
			/**
			 * Tests if the component is of type 1,2,12 or 13
			 */
			final boolean[] leftRight = isAddLeftRight(row, col, comp);
			addEsquerda = leftRight[0];
			addDireita = leftRight[1];
			addPasteEsquerda = leftRight[2];
			addPasteDireita = leftRight[3];

			/**
			 * With a right click on the component one can do -1-cancel 1-add
			 * left 2-add right 3-paste left 4-paste right
			 */
			introMethod = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.IntroMethod(
					JPrograf.jFrameDummy, true, addEsquerda, addDireita, addPasteEsquerda, addPasteDireita);
			new CenterFrame(this, introMethod);
			introMethod.show();
			if (introMethod.getSelOption() == -1) {
				return;
			}
			if (introMethod.getSelOption() == 1) {
				/**
				 * First shift 1 time all the components beginning in the NEXT
				 * column, to the right!
				 */
				shiftColRight(row, col, -1);

				/**
				 * Shift all the components in this column, beginning in THIS
				 * row, to the right
				 */
				shiftColRightLeftSelected(row, col);

				/**
				 * If there is a component at his left, then there must be a
				 * connection
				 */
				if (matrix[row][col + 1] != null) {
					matrixWiring[row][col + 1] = "<-";
				}
				addSelectedButton(posX, posY, 0, false, true);
			} else if (introMethod.getSelOption() == 2) {
				/**
				 * Get the correct column, where to add the button, and if
				 * needed shift the columns to the right
				 */
				final int correctColumn = shiftColRight(row, col, 1);
				matrix[row][correctColumn] = null;
				matrixWiring[row][correctColumn] = "<-";
				addSelectedButton((correctColumn - 1) * COL_WIDTH, posY, 0, false, true);
			} else if (introMethod.getSelOption() == 3) {
				/**
				 * Set the global variables rowToPaste,colToPaste
				 */
				rowToPaste = row;
				colToPaste = col;
				final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] tempBlock = copyPaste.getMatrixData();
				/**
				 * Shift the columns to the right, with the argument -2, to
				 * inform the method that is has to do something special(do not
				 * add horlines) (see shiftColRight)
				 */
				shiftColRight(row, col, -2);

				/**
				 * Shift all the components in this column, beginning in THIS
				 * row, to the right
				 */
				shiftColRightLeftSelected(row, col);

				/**
				 * Create an event with -1 to notify the paste method that is
				 * has to do a left paste
				 */
				final java.awt.event.ActionEvent aEvt = new java.awt.event.ActionEvent((Object) jPanelContainer, -1,
						null);
				jMenuItemPasteActionPerformed(aEvt);

				/**
				 * Adds the needed horLines In ->In the next version try to do
				 * it with updateHorLines()
				 */
				if (matrix[row][col] != null) {
					for (int iCol = col + tempBlock[0].length - 1; iCol > col - 1; iCol--) {
						if (matrix[row][iCol] == null) {
							horLine = new pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine();
							matrix[row][iCol] = horLine;
							matrixWiring[row][iCol] = "<-";
							addCompEvents(horLine);
						}
					}
					matrixWiring[row][tempBlock[0].length + col - 1] = "<-";
					System.out.println("tempBlock[0].length=" + tempBlock[0].length);
					matrix[row][col].setPaintLeft(true);
					matrix[row][col].revalidate();
				}
				updateDisplay(true);
				/**
				 * Re-copy for the reasons already explained
				 */
				jMenuItemCopyActionPerformed(null);
			} else if (introMethod.getSelOption() == 4) {
				/**
				 * Paste in the next column, if it is possible( treated in the
				 * paste method)! Send null event to notify that is right paste
				 */
				rowToPaste = row;
				colToPaste = col + 1;
				jMenuItemPasteActionPerformed(null);
			}
		}
		jPanelContainer.revalidate();
	}

	/**
	 * @param args the command line arguments
	 */
	/** Only for debug!! */
	public static void main(final String args[]) {
		final javax.swing.JFrame jf = new javax.swing.JFrame();
		jf.getContentPane().add(new JPrograf(null));
		jf.pack();
		jf.show();
	}

	/**
	 * Get the column with the mouse X position in the panel
	 */
	public int getColumn(final int x) {
		column = (int) (x / COL_WIDTH + 1);
		if (maxColumn < column) {
			maxColumn = column;
		}
		return column;
	}

	/**
	 * Get the row with the mouse Y position in the panel
	 */
	public int getRow(final int y) {
		row = (int) (y / COL_HEIGHT + 1);
		if (maxRow < row) {
			maxRow = row;
		}
		return row;
	}

	/**
	 * See if it is valid to add a component. It is always ok to add if it has a
	 * component in the row above, that isn't a horLine
	 */
	public boolean isAddCompValid(final int x, final int y, final boolean substitute) {
		if ((jPanelContainer.getComponentAt(x, y - COL_HEIGHT) != null
				&& jPanelContainer.getComponentAt(x, y - COL_HEIGHT) != jPanelContainer && !jPanelContainer
				.getComponentAt(x, y - COL_HEIGHT).getClass().getName()
				.startsWith("pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine"))
				|| (substitute)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Try to add a component in row, col of matrix, and matrixWiring
	 */
	private void addComp(final int row, final int col, final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block comp) {
		/**
		 * If in the component configuration UI the user canceled the addition
		 * of the button, do nothing and return
		 */
		if (comp.isCancel()) {
			actionCanceled = true;
			return;
		}
		/**
		 * Adds the events to the comp
		 */
		addCompEvents(comp);

		/**
		 * Adds the component to the matrix
		 */
		if (matrix[row][col] == null) {
			matrix[row][col] = comp;
		}
		/**
		 * If there isn't space (cell to add!=null), then the user wants to add
		 * a component between two. Shift the row down, and then add the
		 * component
		 */
		else {
			shiftRowDownFixedCol(row, col);
			matrix[row][col] = comp;
		}
		updateDisplay(true);
	}

	/**
	 * The same of addComp, but for components of type 12 or 13 ->Next version
	 * join addComp and addCompAnd
	 */
	private void addCompAnd(final int row, final int col,
			final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block compAnd) {
		if (compAnd.isCancel()) {
			actionCanceled = true;
			return;
		}
		addCompEvents(compAnd);
		if (matrix[row][col] == null) {
			matrix[row][col] = compAnd;
			if (matrixWiring[row][col] != null) {
				/**
				 * If the component is wired, add 1 to <-, meaning comp of type
				 * 12 or 13 with connection
				 */
				if (matrixWiring[row][col].startsWith("<-")) {
					matrixWiring[row][col] = "<-1";
					matrix[row][col].getDataModel().setValor2(1);
				}
			} else {
				matrixWiring[row][col] = "  1";
				matrix[row][col].getDataModel().setValor2(1);
			}
		} else {
			shiftRowDownFixedCol(row, col);
			matrix[row][col] = compAnd;
			if (matrixWiring[row][col] != null) {
				if (matrixWiring[row][col].startsWith("<-")) {
					matrixWiring[row][col] = "<-1";
				}
			} else {
				matrixWiring[row][col] = "  1";
			}
		}
		updateDisplay(true);
	}

	/**
	 * Adds the components two different types of events: mouse pressed,
	 * (horLine doesn't have this event) mouse moved
	 */
	private void addCompEvents(final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block comp) {
		if (comp == null) {
			return;
		}
		if (!isHorLine(comp)) {
			comp.addMouseListener(new java.awt.event.MouseAdapter() {
				public void mousePressed(final java.awt.event.MouseEvent evt2) {
					compMousePressed(evt2);
				}
			});
		}
		comp.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
			public void mouseMoved(final java.awt.event.MouseEvent evt) {
				compMouseMoved(evt);
			}
		});
	}

	/**
	 * Adds the selected button!
	 */
	private void addSelectedButton(final int posX, final int posY, final int tipo, final boolean substitute,
			final boolean paintLeft) {
		final int row = getRow(posY);
		final int col = getColumn(posX);
		if (!isAddCompValid(posX, posY, substitute)) {
			/**
			 * Let add the component to the right of some component
			 */
			if (!paintLeft) {
				return;
			} else {
				matrixWiring[row][col] = "<-";
			}
		}
		/**
		 * Get the selected button, or if it is substituting get the type of the
		 * button to substitute!
		 */
		if ((getSelectedButton() == 1 && !substitute) || (substitute && tipo == 1)) {
			compInt = new pt.utl.ist.elab.client.webrobot.customizer.Comps.CompInt(JPrograf.jFrameDummy);
			addComp(row, col, compInt);
		} else if ((getSelectedButton() == 2 && !substitute) || (substitute && tipo == 2)) {
			compBin = new pt.utl.ist.elab.client.webrobot.customizer.Comps.CompBin(JPrograf.jFrameDummy);
			addComp(row, col, compBin);
		} else if ((getSelectedButton() == 12 && !substitute) || (substitute && tipo == 12)) {
			compAndInt = new pt.utl.ist.elab.client.webrobot.customizer.Comps.CompAndInt(JPrograf.jFrameDummy);
			addCompAnd(row, col, compAndInt);
		} else if ((getSelectedButton() == 13 && !substitute) || (substitute && tipo == 13)) {
			compAndBin = new pt.utl.ist.elab.client.webrobot.customizer.Comps.CompAndBin(JPrograf.jFrameDummy);
			addCompAnd(row, col, compAndBin);
		} else if ((getSelectedButton() == 10 && !substitute) || (substitute && tipo == 10)) {
			atribui = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Atribui(JPrograf.jFrameDummy);
			addComp(row, col, atribui);
		} else if ((getSelectedButton() == 11 && !substitute) || (substitute && tipo == 11)) {
			incDec = new pt.utl.ist.elab.client.webrobot.customizer.Comps.IncDec(JPrograf.jFrameDummy);
			addComp(row, col, incDec);
		} else if ((getSelectedButton() == 9 && !substitute) || (substitute && tipo == 9)) {
			setReset = new pt.utl.ist.elab.client.webrobot.customizer.Comps.SetReset(JPrograf.jFrameDummy);
			addComp(row, col, setReset);
		} else if ((getSelectedButton() == 8 && !substitute) || (substitute && tipo == 8)) {
			pwm = new pt.utl.ist.elab.client.webrobot.customizer.Comps.PWM(JPrograf.jFrameDummy);
			addComp(row, col, pwm);
		} else if ((getSelectedButton() == 14 && !substitute) || (substitute && tipo == 14)) {
			ivpwm = new pt.utl.ist.elab.client.webrobot.customizer.Comps.IVPWM(JPrograf.jFrameDummy,
					JPrograf.modelIVPWM);
			addComp(row, col, ivpwm);
		} else if ((getSelectedButton() == 3 && !substitute) || (substitute && tipo == 3)) {
			frente = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Frente(JPrograf.jFrameDummy);
			addComp(row, col, frente);
		} else if ((getSelectedButton() == 4 && !substitute) || (substitute && tipo == 4)) {
			marchAtras = new pt.utl.ist.elab.client.webrobot.customizer.Comps.MarchAtras(JPrograf.jFrameDummy);
			addComp(row, col, marchAtras);
		} else if ((getSelectedButton() == 5 && !substitute) || (substitute && tipo == 5)) {
			direita = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Direita(JPrograf.jFrameDummy);
			addComp(row, col, direita);
		} else if ((getSelectedButton() == 6 && !substitute) || (substitute && tipo == 6)) {
			esquerda = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Esquerda(JPrograf.jFrameDummy);
			addComp(row, col, esquerda);
		}
	}

	/**
	 * Creates a new block based on the tpye and making a copy of the model of
	 * the component, that is to be copied
	 */
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Block createNewBlock(final int tipo,
			final pt.utl.ist.elab.client.webrobot.customizer.Models.ModelBlock model) {
		if (tipo == 1) {
			compInt = new pt.utl.ist.elab.client.webrobot.customizer.Comps.CompInt(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompInt) model);
			return compInt;
		} else if (tipo == 2) {
			compBin = new pt.utl.ist.elab.client.webrobot.customizer.Comps.CompBin(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompBin) model);
			return compBin;
		} else if (tipo == 12) {
			compAndInt = new pt.utl.ist.elab.client.webrobot.customizer.Comps.CompAndInt(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompAndInt) model);
			return compAndInt;
		} else if (tipo == 13) {
			compAndBin = new pt.utl.ist.elab.client.webrobot.customizer.Comps.CompAndBin(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompAndBin) model);
			return compAndBin;
		} else if (tipo == 10) {
			atribui = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Atribui(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelAtribui) model);
			return atribui;
		} else if (tipo == 11) {
			incDec = new pt.utl.ist.elab.client.webrobot.customizer.Comps.IncDec(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelIncDec) model);
			return incDec;
		} else if (tipo == 9) {
			setReset = new pt.utl.ist.elab.client.webrobot.customizer.Comps.SetReset(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelSetReset) model);
			return setReset;
		} else if (tipo == 8) {
			pwm = new pt.utl.ist.elab.client.webrobot.customizer.Comps.PWM(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelPWM) model);
			return pwm;
		} else if (tipo == 14) {
			ivpwm = new pt.utl.ist.elab.client.webrobot.customizer.Comps.IVPWM(JPrograf.modelIVPWM);
			return ivpwm;
		} else if (tipo == 3) {
			frente = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Frente(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelFrente) model);
			return frente;
		} else if (tipo == 4) {
			marchAtras = new pt.utl.ist.elab.client.webrobot.customizer.Comps.MarchAtras(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelMarchAtras) model);
			return marchAtras;
		} else if (tipo == 5) {
			direita = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Direita(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelDireita) model);
			return direita;
		} else if (tipo == 6) {
			esquerda = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Esquerda(
					(pt.utl.ist.elab.client.webrobot.customizer.Models.ModelEsquerda) model);
			return esquerda;
		}
		return null;
	}

	/**
	 * Creates a new model for a component, based on the component type
	 */
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelBlock getModel(final int tipo) {
		if (tipo == 1) {
			modelCompInt = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompInt();
			return modelCompInt;
		} else if (tipo == 2) {
			modelCompBin = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompBin();
			return modelCompBin;
		} else if (tipo == 3) {
			modelFrente = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelFrente();
			return modelFrente;
		} else if (tipo == 4) {
			modelMarchAtras = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelMarchAtras();
			return modelMarchAtras;
		} else if (tipo == 5) {
			modelDireita = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelDireita();
			return modelDireita;
		} else if (tipo == 6) {
			modelEsquerda = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelEsquerda();
			return modelEsquerda;
		} else if (tipo == 8) {
			modelPWM = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelPWM();
			return modelPWM;
		} else if (tipo == 9) {
			modelSetReset = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelSetReset();
			return modelSetReset;
		} else if (tipo == 10) {
			modelAtribui = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelAtribui();
			return modelAtribui;
		} else if (tipo == 11) {
			modelIncDec = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelIncDec();
			return modelIncDec;
		} else if (tipo == 12) {
			modelCompAndInt = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompAndInt();
			return modelCompAndInt;
		} else if (tipo == 13) {
			modelCompAndBin = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompAndBin();
			return modelCompAndBin;
		} else if (tipo == 14) {
			return JPrograf.modelIVPWM;
		}
		return null;
	}

	/**
	 * See what button is selected
	 */
	private int getSelectedButton() {
		if (jToggleButtonCNI.isSelected()) {
			return 1;
		} else if (jToggleButtonCB.isSelected()) {
			return 2;
		} else if (jToggleButtonCNIAL.isSelected()) {
			return 12;
		} else if (jToggleButtonCBAL.isSelected()) {
			return 13;
		} else if (jToggleButtonAtribui.isSelected()) {
			return 10;
		} else if (jToggleButtonIncDec.isSelected()) {
			return 11;
		} else if (jToggleButtonSetReset.isSelected()) {
			return 9;
		} else if (jToggleButtonPWM.isSelected()) {
			return 8;
		} else if (jToggleButtonIVPWM.isSelected()) {
			return 14;
		} else if (jToggleButtonFrente.isSelected()) {
			return 3;
		} else if (jToggleButtonMarchAtras.isSelected()) {
			return 4;
		} else if (jToggleButtonDireita.isSelected()) {
			return 5;
		} else if (jToggleButtonEsquerda.isSelected()) {
			return 6;
		}
		return 1;
	}

	/**
	 * Shift one time all the rows down Exp: X-X-X-X-X-X-X X-X X X-X<-SHIFT
	 * BEGINS AT ROW 4, COL1 X ... X-X-X-X-X-X-X X-X X SHIFTED (All the comps
	 * that had connections in this col, went down X-X has well) X
	 */
	private void shiftRowDownFixedCol(final int row, final int col) {
		final int maxColAllowed = getMaxAllowedColumn(row, col);
		for (int iRow = maxRow; iRow > row - 1; iRow--) {
			for (int iCol = col; iCol < maxColAllowed; iCol++) {
				matrix[iRow + 1][iCol] = matrix[iRow][iCol];
				matrixWiring[iRow + 1][iCol] = matrixWiring[iRow][iCol];
				matrix[iRow][iCol] = null;
				matrixWiring[iRow][iCol] = null;
			}
		}
		maxRow++;
	}

	/**
	 * The same of the previous method, but brings rows UP. Meaning the row+n+1
	 * to row+n
	 */
	private void shiftRowUpFixedCol(final int row, final int col) {
		final int maxColAllowed = getMaxAllowedColumn(row, col);
		for (int iRow = row; iRow < maxRow + 1; iRow++) {
			for (int iCol = col; iCol < maxColAllowed; iCol++) {
				matrix[iRow][iCol] = matrix[iRow + 1][iCol];
				matrixWiring[iRow][iCol] = matrixWiring[iRow + 1][iCol];
				matrix[iRow + 1][iCol] = null;
				matrixWiring[iRow + 1][iCol] = null;
			}
		}
	}

	/**
	 * Shift the columns to the right, and returns the column, where the
	 * components to insert should be inserted!
	 */
	private int shiftColRight(final int row, final int col, int enlargeColToReturn) {
		int colToReturn = col + 1;
		final int originalRow = row;
		for (int iCol = col + 1; iCol < maxColumn + 1; iCol++) {
			/**
			 * If one didn't want to arrive to maxColumn, since it found a
			 * larger column in the way! Without this precaution it would
			 * increment wrongly
			 */
			if (matrix[row][iCol] != null) {
				if (!isHorLine(row, iCol)) {
					break;
				}
			}
			for (int iRow = row + 1; iRow < maxRow + 1; iRow++) {
				/**
				 * If is paste left(enlarge column==-2), don't do this...
				 */
				if (matrix[iRow][iCol] != null && enlargeColToReturn != -2) {
					horLine = new pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine();
					matrix[originalRow][iCol] = horLine;
					matrixWiring[originalRow][iCol] = "<-";
					addCompEvents(horLine);
					colToReturn++;
					break;
				}
			}
		}
		maxColumn++;

		/**
		 * When adding left, always shift from maxColumn, to the column where to
		 * add the block
		 */
		if (enlargeColToReturn == -1 && (colToReturn != (col + 1))) {
			colToReturn = col + 1;
		}

		/**
		 * Do the right shifting!
		 */
		for (int iCol = maxColumn + 1; iCol > (colToReturn - 1); iCol--) {
			for (int iRow = 1; iRow < maxRow + 1; iRow++) {
				matrix[iRow][iCol + 1] = matrix[iRow][iCol];
				matrixWiring[iRow][iCol + 1] = matrixWiring[iRow][iCol];
				matrix[iRow][iCol] = null;
				matrixWiring[iRow][iCol] = null;
			}
		}
		/**
		 * Adds the horlines, that weren't added before ->Next version try to do
		 * it with updateHorLines method
		 */
		for (int iRow = row - 1; iRow > 0; iRow--) {
			if (matrixWiring[iRow][colToReturn + 1] != null) {
				if (matrixWiring[iRow][colToReturn + 1].startsWith("<-")) {
					horLine = new pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine();
					matrix[iRow][colToReturn] = horLine;
					matrixWiring[iRow][colToReturn] = "<-";
					addCompEvents(horLine);
				}
			}
		}
		/**
		 * To the case of pasting, repeat the shifting for enlargeColToReturn
		 * times
		 */
		enlargeColToReturn--;
		if (enlargeColToReturn > 0) {
			shiftColRight(row, col, enlargeColToReturn);
		}
		return colToReturn;
	}

	/**
	 * Method called from addLeft and pasteLeft: Shift all the components in
	 * this column, beginning in THIS row, to the right
	 */
	private void shiftColRightLeftSelected(final int row, final int col) {
		for (int iRow = row; iRow < maxRow + 1; iRow++) {
			matrix[iRow][col + 1] = matrix[iRow][col];
			matrixWiring[iRow][col + 1] = matrixWiring[iRow][col];
			matrix[iRow][col] = null;
			matrixWiring[iRow][col] = null;
		}
	}

	/**
	 * Shift the columns one time to the place of col. Meaning that col+n+1
	 * becomes col+n
	 */
	private void shiftColLeft(final int row, final int col) {
		for (int iCol = col; iCol < maxColumn; iCol++) {
			for (int iRow = 0; iRow < maxRow + 1; iRow++) {
				if (matrix[iRow][iCol] != null && (matrix[iRow][iCol + 1] == null || isHorLine(iRow, iCol + 1))) {
					continue;
				}
				matrix[iRow][iCol] = matrix[iRow][iCol + 1];
				matrixWiring[iRow][iCol] = matrixWiring[iRow][iCol + 1];
				matrix[iRow][iCol + 1] = null;
				matrixWiring[iRow][iCol + 1] = null;
			}
		}
	}

	/**
	 * Deletes a block! If delColumn is selected, than don't test if it can
	 * delete a block!
	 */
	private void delBlock(final int row, final int col, final boolean delColumn) {
		/**
		 * Can't delete a block, if it a comparison block, and the block at
		 * row+1 isn't of comparison, or if the block at row-1 is null and the
		 * block at row isn't of comparison!
		 */
		if (isConnectionBlock(matrix[row][col]) && !delColumn) {
			if ((matrix[row + 1][col] != null && !isConnectionBlock(matrix[row + 1][col])
					&& matrix[row - 1][col] != null && !isConnectionBlock(matrix[row - 1][col]))
					|| (matrix[row + 1][col] != null && !isConnectionBlock(matrix[row + 1][col]) && matrix[row - 1][col] == null)) {
				javax.swing.JOptionPane.showMessageDialog(this, "N�o pode apagar o bloco de compara��o!", "Erro!",
						javax.swing.JOptionPane.ERROR_MESSAGE);
				return;
			}
		}
		/**
		 * If the component add a connection with the component at its left, I
		 * don't want to lose the connection!
		 */
		boolean wasAddLeft = false;
		matrix[row][col] = null;
		if (matrixWiring[row][col] != null) {
			if (matrixWiring[row][col].startsWith("<-")) {
				wasAddLeft = true;
			}
		}
		matrixWiring[row][col] = null;
		/**
		 * Bring all the components up
		 */
		shiftRowUpFixedCol(row, col);
		if (wasAddLeft && matrix[row][col - 1] != null) {
			matrixWiring[row][col] = "<-";
		}
		/**
		 * If it tried to shift up, and there weren't components to shift up,
		 * then try to move all the components at its right, one time to the
		 * left! (matrixWiring[row][col+1].startsWith("<-")for the case of block
		 * of type 12 or 13)
		 */
		if ((matrix[row][col] == null && matrixWiring[row][col + 1] != null && matrixWiring[row][col + 1]
				.startsWith("<-")) || isColEmpty(col)) {
			shiftColLeft(row, col);
			shiftedColsInDel = true;
		}
	}

	/**
	 * The method that takes care of updating the data of the bottom of the
	 * panel
	 */
	private void updateBottomPanel(final int x, final int y) {
		final int rowCl = (int) (y / COL_HEIGHT + 1);
		final int colCl = (int) (x / COL_WIDTH + 1);
		jLabelNumComps.setText("N� total de blocos = " + countTotalBlocks());
		jLabelRow.setText("Linha = " + rowCl);
		jLabelCol.setText("Coluna = " + colCl);
		if (matrix[rowCl][colCl] == null) {
			jLabelCompName.setText("Bloco =");
		} else {
			jLabelCompName.setText("Bloco = " + matrix[rowCl][colCl].getFullNameDescription());
		}
	}

	/**
	 * Clears all the blocks in the jPanel, and reinserts the jButtonProgStart
	 */
	private void clearDisplay() {
		jPanelContainer.removeAll();
		jPanelContainer.add(jButtonProgStart, new AbsoluteConstraints(0, 0, -1, -1));
		jPanelContainer.updateUI();
	}

	/**
	 * Cleans all the matrix and resets the UNDO
	 */
	private void resetMatrix() {
		for (int iRow = 0; iRow < maxRow + 1; iRow++) {
			for (int iCol = 0; iCol < maxColumn + 1; iCol++) {
				matrix[iRow][iCol] = null;
				matrixWiring[iRow][iCol] = null;
			}
		}
		JPrograf.undoBlock = null;
		JPrograf.undoWiring = null;
		JPrograf.undoBlock = new Undo();
		JPrograf.undoWiring = new Undo();
		/**
		 * Two times for undo reasons...ugly, change in next version
		 */
		updateDisplay(true);
		updateDisplay(true);
	}

	/**
	 * Cleans horLines that might rest...this is a security method...I might
	 * lose in optimization, but win in security...
	 */
	private void cleanFalseHorLines() {
		for (int iCol = maxColumn + 1; iCol > 0; iCol--) {
			for (int iRow = 1; iRow < maxRow + 1; iRow++) {
				if (matrix[iRow][iCol] == null) {
					continue;
				} else if (isHorLine(iRow, iCol) && matrix[iRow][iCol + 1] == null) {
					jPanelContainer.remove(matrix[row][iCol]);
					matrix[iRow][iCol] = null;
					matrixWiring[iRow][iCol] = null;
				}
			}
		}
	}

	/**
	 * Returns the first row that ISN'T null in this column
	 */
	private int getFirtNonNullRow(final int col) {
		for (int iRow = 0; iRow < maxRow + 1; iRow++) {
			if (matrix[iRow][col] != null && !isHorLine(iRow, col)) {
				return iRow;
			}
		}
		return 0;
	}

	/**
	 * Returns the real maxRow...as explained before, maxRow is only for reasons
	 * of optimization, this returns the real last non null row
	 */
	private int getLastNonNullRow() {
		int iRow = 1;
		boolean allRowEmpty = false;
		for (iRow = 2; iRow < maxRow + 2; iRow++) {
			if (allRowEmpty) {
				break;
			}
			for (int iCol = 1; iCol < maxColumn + 1; iCol++) {
				allRowEmpty = true;
				if (matrix[iRow][iCol] != null) {
					allRowEmpty = false;
					break;
				}
			}
		}
		return iRow;
	}

	/**
	 * The scope of this method is to get the real max column in respect of col:
	 * for example if one needs to copy a column, one needs to know until which
	 * column should it copy. Example: Copy col 1 X--X X-X<-This is the
	 * maxAllowedColumn!!!(row 3) XX X Since the third row has a connection with
	 * a component in the third column this method will return 3. And one knows
	 * that must copy, or delete, etc. until col 3. (remember that the copy
	 * method, starts to check for connections at row+1!!)
	 */
	private int getMaxAllowedColumn(final int row, final int col) {
		int maxColAllowed = col;
		boolean abort = false;
		if (matrix[row + 1][col] == null) {
			return (maxColAllowed + 1);
		}
		for (int iCol = col; iCol < maxColumn + 2; iCol++) {
			if (abort) {
				maxColAllowed = iCol;
				break;
			}
			for (int iRow = row + 1; iRow < maxRow + 1; iRow++) {
				abort = true;
				if (matrixWiring[iRow][iCol + 1] != null) {
					if (matrixWiring[iRow][iCol + 1].startsWith("<-")) {
						abort = false;
						break;
					}
				}
			}
		}
		return maxColAllowed;
	}

	/**
	 * Checks if in the matrix at the position (rowXcol), there is a HorLine
	 */
	private boolean isHorLine(final int row, final int col) {
		if (matrix[row][col] == null) {
			return false;
		} else if (matrix[row][col].getClass().getName()
				.startsWith("pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine")) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Checks if the block is a HorLine
	 */
	private boolean isHorLine(final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block comp) {
		if (comp == null) {
			return false;
		} else if (comp.getClass().getName().startsWith("pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine")) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * This method is used to see if the column is empty HorLines don't count as
	 * blocks, meaning that a column with horLines will return empty!
	 */
	private boolean isColEmpty(final int col) {
		boolean empty = true;
		for (int iRow = 2; iRow < maxRow + 1; iRow++) {
			if (matrix[iRow][col] != null && !isHorLine(iRow, col)) {
				empty = false;
			}
		}
		return empty;
	}

	/**
	 * Tests if a component is of type 1,2,12 or 13
	 */
	private boolean isConnectionBlock(final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block comp) {
		if (comp == null) {
			return false;
		}
		if (comp.getTipo() != 1 && comp.getTipo() != 2 && comp.getTipo() != 12 && comp.getTipo() != 13) {
			return false;
		} else {
			return true;
		}
	}

	/**
	 * This method returns what can be choosen for the selected component if one
	 * clicks in it with the right button Tests: 1-Can have addLeft 2-Can have
	 * addRight 3-Can have pasteLeft 4-Can have pasteRight
	 */
	private boolean[] isAddLeftRight(final int row, final int col,
			final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block comp) {
		final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] tempPaste = copyPaste.getMatrixData();
		final boolean[] retBoolean = new boolean[4];
		if (comp == null) {
			retBoolean[0] = false;
			retBoolean[1] = false;
			retBoolean[2] = false;
			retBoolean[3] = false;
			return retBoolean;
		}
		if (matrix[row - 1][col] != null) {
			if ((matrix[row - 1][col].getTipo() == 12 || matrix[row - 1][col].getTipo() == 13)
					&& (comp.getTipo() == 12 || comp.getTipo() == 13)) {
				retBoolean[0] = false;
				retBoolean[1] = false;
				retBoolean[2] = false;
				retBoolean[3] = false;
				return retBoolean;
			}
		}
		if (!isConnectionBlock(comp)) {
			retBoolean[0] = false;
			retBoolean[1] = false;
			retBoolean[2] = false;
			retBoolean[3] = false;
			return retBoolean;
		}
		if (getSelectedButton() != 1 && getSelectedButton() != 2 && getSelectedButton() != 12
				&& getSelectedButton() != 13) {
			retBoolean[0] = false;
			retBoolean[1] = false;
			if (isConnectionBlock(tempPaste[1][1])) {
				retBoolean[3] = true;
				if (matrix[row][col - 1] == null) {
					retBoolean[2] = true;
				} else {
					retBoolean[2] = false;
				}
			} else {
				retBoolean[2] = false;
				retBoolean[3] = false;
			}
			return retBoolean;
		}
		if (matrix[row][col - 1] == null) {
			retBoolean[0] = true;
		} else {
			retBoolean[0] = false;
		}
		retBoolean[1] = true;
		if (isConnectionBlock(tempPaste[1][1])) {
			retBoolean[3] = true;
			if (matrix[row][col - 1] == null) {
				retBoolean[2] = true;
			} else {
				retBoolean[2] = false;
			}
		} else {
			retBoolean[2] = false;
			retBoolean[3] = false;
		}
		return retBoolean;
	}

	/**
	 * This method counts the number of blocks in the matrix, horlines don't
	 * count
	 */
	private int countTotalBlocks() {
		int totalBlocks = 0;
		for (int iRow = 0; iRow < maxRow + 1; iRow++) {
			for (int iCol = 0; iCol < maxColumn + 1; iCol++) {
				if (matrix[iRow][iCol] != null) {
					if (!isHorLine(iRow, iCol)) {
						totalBlocks++;
					}
				}
			}
		}
		return totalBlocks;
	}

	/**
	 * This is a new method, implemented with the scope to work only with open
	 * file (creating horlines for the blocks created, after opening the file)
	 * ->In the next version, improve the method, and any method that want to
	 * update horlines will call this!
	 */
	public void updateHorLines() {
		for (int iRow = 2; iRow < maxRow; iRow++) {
			for (int iCol = maxColumn + 1; iCol > 1; iCol--) {
				if (matrixWiring[iRow][iCol] != null && matrixWiring[iRow][iCol].startsWith("<-")
						&& matrix[iRow][iCol - 1] == null) {
					horLine = new pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine();
					matrix[iRow][iCol - 1] = horLine;
					matrixWiring[iRow][iCol - 1] = "<-";
					addCompEvents(horLine);
				}
			}
		}
	}

	/**
	 * Draw the matrix in the screen
	 */
	private void updateDisplay(final boolean addToUndo) {
		/**
		 * First clean all the blocks
		 */
		clearDisplay();
		for (int col = 1; col < maxColumn + 1; col++) {
			for (int row = 1; row < maxRow + 1; row++) {
				if (matrix[row][col] == null) {
					/**
					 * Security cleaning Where there isn't a component, or a
					 * HorLine, can't be a connection
					 */
					if (matrixWiring[row][col] != null) {
						matrixWiring[row][col] = null;
					}
					continue;
				}
				/**
				 * Adds the component to the jPanel
				 */
				jPanelContainer.add(matrix[row][col], new AbsoluteConstraints((col - 1) * COL_WIDTH, (row - 1)
						* COL_HEIGHT, -1, -1));
				matrix[row][col].revalidate();
				/**
				 * If there is a component up, then this one must paint a
				 * connection with this one!
				 */
				if (matrix[row - 1][col] != null && matrix[row][col] != null) {
					matrix[row - 1][col].setPaintBottom(true);
					matrix[row - 1][col].revalidate();
				}
				/**
				 * Paint left connections
				 */
				if (matrixWiring[row][col] != null) {
					if (matrixWiring[row][col].startsWith("<-")) {
						if (matrix[row][col - 1] != null) {
							matrix[row][col - 1].setPaintLeft(true);
							matrix[row][col - 1].revalidate();
						}
					}
					/**
					 * Paint other ands connections
					 */
					if (matrixWiring[row - 1][col] != null && matrixWiring[row][col].length() > 2
							&& matrixWiring[row - 1][col].length() > 2) {
						if ((matrixWiring[row][col].charAt(2) == '1')
								&& (matrixWiring[row - 1][col].charAt(2) == '1' || matrixWiring[row - 1][col].charAt(2) == '2')) {
							matrix[row - 1][col].setPaintBottom(true);
							matrix[row - 1][col].setAnotherAnd(true);
							matrixWiring[row][col].replace('1', '2');
							matrix[row][col].getDataModel().setValor2(2);
						}
					}
				}

				/**
				 * This is for security...maybe it isn't very beautiful...the
				 * program should do exactly what it is told to do...but I don't
				 * want strange things to happen (like connection with nothing,
				 * etc.) ->Next version this must go...
				 */
				cleanFalseHorLines();
				if (matrix[row][col] != null) {
					/**
					 * If it has arrived here, then there where changes...don't
					 * let the user close the program without notifying him...
					 */
					haveBeenChanges = true;
					if (matrixWiring[row][col] != null && matrixWiring[row][col].startsWith("<-")
							&& matrix[row][col - 1] == null) {
						matrixWiring[row][col] = null;
					}
					if ((matrix[row][col].isPaintLeft())
							& (matrix[row][col + 1] == null || matrixWiring[row][col + 1] == null)) {
						matrix[row][col].setPaintLeft(false);
						matrix[row][col].revalidate();
					}
					if (matrix[row][col].isPaintBottom() && matrix[row + 1][col] == null) {
						matrix[row][col].setPaintBottom(false);
						matrix[row][col].revalidate();
					}
					if ((matrix[row][col].isAnotherAnd() && matrix[row + 1][col] != null && (matrix[row + 1][col]
							.getTipo() != 12 && matrix[row + 1][col].getTipo() != 13))
							|| (matrix[row][col].isAnotherAnd() && matrix[row + 1][col] == null)) {
						matrix[row][col].setAnotherAnd(false);
						matrix[row][col].getDataModel().setValor2(1);
					}
				}
			}
		}

		/**
		 * Adds to undo the new changes! Notice that updating the display
		 * doesn't imply adding to undo! Maybe I'm just drawing connection, and
		 * this isn't added to undo!
		 */
		if (addToUndo) {
			final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] matrixUndo = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[maxRow + 5][maxColumn + 5];
			final String[][] matrixWiringUndo = new String[maxRow + 5][maxColumn + 5];
			for (int iRow = 0; iRow < maxRow + 1; iRow++) {
				for (int iCol = 0; iCol < maxColumn + 1; iCol++) {
					matrixUndo[iRow][iCol] = matrix[iRow][iCol];
					matrixWiringUndo[iRow][iCol] = matrixWiring[iRow][iCol];
				}
			}
			JPrograf.undoBlock.addElement(matrixUndo);
			JPrograf.undoWiring.addElement(matrixWiringUndo);
		}
		jPanelContainer.revalidate();
	}

	private void openFile(final java.io.InputStream is) throws java.io.IOException {
		String data;
		endedRowCol = false;// for treatData()!
		counter = 0;// for treatData()!
		int check;
		final int lineSeparator = (int) System.getProperty("line.separator").charAt(0);
		StringBuffer buffer = new StringBuffer(100);
		;

		try {
			buffer = new StringBuffer(200);
			while ((check = is.read()) != -1) {
				/**
				 * If the file isn't valid (like doesn't follow the Prograf
				 * rules to save, abort
				 */
				if (!isFileValid) {
					is.close();
					return;
				}
				/**
				 * Adds the arriving chars to a stringbuffer and send it to
				 * treatData()
				 */
				buffer.append((char) check);
				if (check == lineSeparator) {
					data = buffer.toString().trim();
					treatData(data);
					buffer = new StringBuffer(200);
				}
			}
			/**
			 * to send the last line!
			 */
			data = buffer.toString().trim();
			treatData(data);
		} catch (final java.io.IOException ioe) {
			System.out.println(ioe);
		}
		is.close();
		/**
		 * Make the connections between components that aren't side by side!
		 */
		updateHorLines();
		updateDisplay(true);
	}

	/**
	 * This opens the file and then sends every line of information to
	 * treatData()
	 */
	private void openFile(final java.io.File openFile) throws java.io.IOException {
		String data;
		endedRowCol = false;// for treatData()!
		counter = 0;// for treatData()!
		int check;
		final int lineSeparator = (int) System.getProperty("line.separator").charAt(0);
		StringBuffer buffer = new StringBuffer(100);
		;
		final java.io.FileInputStream fileInputStream = new java.io.FileInputStream(openFile);

		try {
			buffer = new StringBuffer(200);
			while ((check = fileInputStream.read()) != -1) {
				/**
				 * If the file isn't valid (like doesn't follow the Prograf
				 * rules to save, abort
				 */
				if (!isFileValid) {
					fileInputStream.close();
					return;
				}
				/**
				 * Adds the arriving chars to a stringbuffer and send it to
				 * treatData()
				 */
				buffer.append((char) check);
				if (check == lineSeparator) {
					data = buffer.toString().trim();
					treatData(data);
					buffer = new StringBuffer(200);
				}
			}
			/**
			 * to send the last line!
			 */
			data = buffer.toString().trim();
			treatData(data);
		} catch (final java.io.IOException ioe) {
			System.out.println(ioe);
		}
		fileInputStream.close();
		/**
		 * Make the connections between components that aren't side by side!
		 */
		updateHorLines();
		updateDisplay(true);
	}

	/**
	 * Treats the data: creates new components, and new models with the data
	 * from the file! The method is very obvious but long...
	 */
	private void treatData(final String data) {
		int coluna = 0;
		int nivel = 0;
		int tipo = 0;
		String d1 = " ";
		String d2 = " ";
		String d3 = " ";
		int valor = 0;
		int valor2 = 0;
		int flag = 0;
		String baixo = "b";
		String temp;
		String esquerda = "b";
		int numLeft = 0;
		String temp2;
		pt.utl.ist.elab.client.webrobot.customizer.Models.ModelBlock model;
		pt.utl.ist.elab.client.webrobot.customizer.Comps.Block comp;

		if (data.startsWith("--->")) {
			return;
		}
		if (data.startsWith("k")) {
			endedRowCol = true;
			return;
		}
		if (!endedRowCol) {
			final java.util.StringTokenizer st = new java.util.StringTokenizer(data, ",");
			while (st.hasMoreTokens()) {
				try {
					coluna = Integer.parseInt(st.nextToken().trim().substring("coluna=".length()));
					nivel = Integer.parseInt(st.nextToken().trim().substring("nivel=".length()));
					tipo = Integer.parseInt(st.nextToken().trim().substring("tipo=".length()));
					d1 = st.nextToken().trim().substring("d1=".length());
					if (d1.length() == 0) {
						d1 = " ";
					}
					d2 = st.nextToken().trim().substring("d2=".length());
					if (d2.length() == 0) {
						d2 = " ";
					}
					d3 = st.nextToken().trim().substring("d3=".length());
					if (d3.length() == 0) {
						d3 = " ";
					}
					valor = Integer.parseInt(st.nextToken().trim().substring("valor=".length()));
					valor2 = Integer.parseInt(st.nextToken().trim().substring("valor2=".length()));
					temp = st.nextToken().trim();
					final java.util.StringTokenizer st2 = new java.util.StringTokenizer(temp);
					while (st2.hasMoreTokens()) {
						flag = Integer.parseInt(st2.nextToken().trim().substring("flag=".length()));
						baixo = st2.nextToken().trim().substring("baixo=".length());
					}
					temp2 = st.nextToken().trim();
					final java.util.StringTokenizer st3 = new java.util.StringTokenizer(temp2);
					if (st3.countTokens() == 1) {
						esquerda = st3.nextToken().trim().substring("esquerda=".length());
					} else {
						esquerda = st3.nextToken().trim().substring("esquerda=".length());
						numLeft = Integer.parseInt(st3.nextToken().trim());
					}
					model = getModel(tipo);
					model.setBaixo(baixo.charAt(0));
					model.setColuna(coluna);
					model.setD1(d1);
					model.setD2(d2);
					model.setD3(d3);
					model.setEsquerda(esquerda.charAt(0));
					model.setFlag(flag);
					model.setNivel(nivel);
					model.setValor(valor);
					model.setValor2(valor2);
					comp = createNewBlock(tipo, model);
					if (baixo.charAt(0) == 'a') {
						comp.setPaintBottom(true);
					}
					if (esquerda.charAt(0) == 'a') {
						matrixWiring[nivel][coluna] = "<-";
					}
					if (valor2 == 1 || valor2 == 2) {
						if (matrixWiring[nivel][coluna] != null) {
							if (matrixWiring[nivel][coluna].startsWith("<-")) {
								matrixWiring[nivel][coluna] = "<-1";
							}
						} else {
							matrixWiring[nivel][coluna] = "  1";
						}
					}
					addCompEvents(comp);
					matrix[nivel][coluna] = comp;
					matrix[nivel][coluna].revalidate();
					if (coluna > maxColumn) {
						maxColumn = coluna;
					}
					if (nivel > maxRow) {
						maxRow = nivel;
					}
					return;
				} catch (final java.lang.NumberFormatException nfe) {
					javax.swing.JOptionPane.showMessageDialog(this, "Aten��o!\nEste ficheiro n�o � v�lido!", "Erro!",
							javax.swing.JOptionPane.ERROR_MESSAGE);
					isFileValid = false;
					return;
				}
			}
		}

		counter++;

		if (counter == 1) {
			return;
		} else if (counter == 2) {
			return;
		} else if (counter == 3) {
			return;
		} else if (counter == 4) {
			try {
				final java.util.StringTokenizer st4 = new java.util.StringTokenizer(data);
				JPrograf.modelConfInOut.setB0(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setB1(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setB2(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setB3(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setB4(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setB5(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setB6(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setB7(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setC0(Integer.parseInt(st4.nextToken()));
				JPrograf.modelConfInOut.setC3(Integer.parseInt(st4.nextToken()));
				return;
			} catch (final java.lang.NumberFormatException nfe) {
				javax.swing.JOptionPane.showMessageDialog(this, "Aten��o!\nEste ficheiro n�o � v�lido!", "Erro!",
						javax.swing.JOptionPane.ERROR_MESSAGE);
				isFileValid = false;
				return;
			}
		} else if (counter == 5) {
			try {
				final java.util.StringTokenizer st5 = new java.util.StringTokenizer(data);
				JPrograf.modelConfInOut.setA1(Integer.parseInt(st5.nextToken()));
				JPrograf.modelConfInOut.setA2(Integer.parseInt(st5.nextToken()));
				JPrograf.modelConfInOut.setA3(Integer.parseInt(st5.nextToken()));
				JPrograf.modelConfInOut.setA4(Integer.parseInt(st5.nextToken()));
				final String dummyVar = st5.nextToken();
				return;
			} catch (final java.lang.NumberFormatException nfe) {
				javax.swing.JOptionPane.showMessageDialog(this, "Aten��o!\nEste ficheiro n�o � v�lido!", "Erro!",
						javax.swing.JOptionPane.ERROR_MESSAGE);
				isFileValid = false;
				return;
			}
		} else if (counter == 6) {
			try {
				final java.util.StringTokenizer st6 = new java.util.StringTokenizer(data);
				JPrograf.modelConfInOut.setV1(Integer.parseInt(st6.nextToken()));
				JPrograf.modelConfInOut.setV2(Integer.parseInt(st6.nextToken()));
				JPrograf.modelConfInOut.setV3(Integer.parseInt(st6.nextToken()));
				JPrograf.modelConfInOut.setV4(Integer.parseInt(st6.nextToken()));
				JPrograf.modelConfInOut.setV5(Integer.parseInt(st6.nextToken()));
			} catch (final java.lang.NumberFormatException nfe) {
				javax.swing.JOptionPane.showMessageDialog(this, "Aten��o!\nEste ficheiro n�o � v�lido!", "Erro!",
						javax.swing.JOptionPane.ERROR_MESSAGE);
				isFileValid = false;
				return;
			}
			confInOut.setModel(JPrograf.modelConfInOut);
			confInOut.readModel();
			return;
		}
		if (counter == 7) {
			iValuesSize = Integer.parseInt(data.substring(1));
			iValues = new Object[iValuesSize][3];
			counter2 = 0;
			return;
		}
		if (counter2 < iValuesSize) {
			final java.util.StringTokenizer st = new java.util.StringTokenizer(data, "\t");
			iValues[counter2][0] = st.nextToken();
			iValues[counter2][1] = new Integer(st.nextToken().trim());
			iValues[counter2][2] = new Integer(st.nextToken().trim());
			counter2++;
			counter = 7;
			return;
		}
		JPrograf.modelIVPWM.setIValues(iValues);
		if (counter == 8) {
			final java.util.StringTokenizer st2 = new java.util.StringTokenizer(data);
			JPrograf.modelIVPWM.setI0Value(Integer.parseInt(st2.nextToken().trim()));
			JPrograf.modelIVPWM.setI1Value(Integer.parseInt(st2.nextToken().trim()));
			JPrograf.modelIVPWM.setI2Value(Integer.parseInt(st2.nextToken().trim()));
			JPrograf.modelIVPWM.setI3Value(Integer.parseInt(st2.nextToken().trim()));
			JPrograf.modelIVPWM.setI4Value(Integer.parseInt(st2.nextToken().trim()));
			JPrograf.modelIVPWM.setI5Value(Integer.parseInt(st2.nextToken().trim()));
			JPrograf.modelIVPWM.setI6Value(Integer.parseInt(st2.nextToken().trim()));
			JPrograf.modelIVPWM.setI7Value(Integer.parseInt(st2.nextToken().trim()));
			return;
		}
		if (counter == 9) {
			final java.util.StringTokenizer st3 = new java.util.StringTokenizer(data);
			JPrograf.modelIVPWM.setI0State(Integer.parseInt(st3.nextToken().trim()));
			JPrograf.modelIVPWM.setI1State(Integer.parseInt(st3.nextToken().trim()));
			JPrograf.modelIVPWM.setI2State(Integer.parseInt(st3.nextToken().trim()));
			JPrograf.modelIVPWM.setI3State(Integer.parseInt(st3.nextToken().trim()));
			JPrograf.modelIVPWM.setI4State(Integer.parseInt(st3.nextToken().trim()));
			JPrograf.modelIVPWM.setI5State(Integer.parseInt(st3.nextToken().trim()));
			JPrograf.modelIVPWM.setI6State(Integer.parseInt(st3.nextToken().trim()));
			JPrograf.modelIVPWM.setI7State(Integer.parseInt(st3.nextToken().trim()));
		}
		/**
		 * The ivpwm share all the same model...update the model, so it can read
		 * the right values....if the user selects to edit or to create a new
		 * one
		 */
		ivpwm = new pt.utl.ist.elab.client.webrobot.customizer.Comps.IVPWM(JPrograf.modelIVPWM);
	}

	/**
	 * Getter for property runStandAloneApp.
	 * 
	 * @return Value of property runStandAloneApp.
	 */
	public boolean isRunStandAloneApp() {
		return runStandAloneApp;
	}

	/**
	 * Setter for property runStandAloneApp.
	 * 
	 * @param runStandAloneApp New value of property runStandAloneApp.
	 */
	public void setRunStandAloneApp(final boolean runStandAloneApp) {
		this.runStandAloneApp = runStandAloneApp;
	}

	private HardwareInfo hardwareInfo = null;
	private HardwareAcquisitionConfig acqConfig = null;

	public HardwareAcquisitionConfig getAcquisitionConfig() {
		return acqConfig;
	}

	public void setHardwareAcquisitionConfig(final HardwareAcquisitionConfig acqConfig) {
		this.acqConfig = acqConfig;
	}

	public void setHardwareInfo(final HardwareInfo hardwareInfo) {
		this.hardwareInfo = hardwareInfo;
	}

	protected HardwareInfo getHardwareInfo() {
		return hardwareInfo;
	}

	public javax.swing.JMenuBar getMenuBar() {
		return jMenuBar;
	}

	public javax.swing.JComponent getCustomizerComponent() {
		return this;
	}

	public javax.swing.ImageIcon getCustomizerIcon() {
		return iconPrograf;
	}

	public String getCustomizerTitle() {
		return JPrograf.TITLE_VERSION;
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.ButtonGroup buttonGroupToolBar;
	private javax.swing.JButton jButton1;
	private javax.swing.JButton jButtonCancel;
	private javax.swing.JButton jButtonOK;
	private javax.swing.JFileChooser jFileChooserOpen;
	private javax.swing.JFileChooser jFileChooserSave;
	private javax.swing.JLabel jLabelCol;
	private javax.swing.JLabel jLabelCompName;
	private javax.swing.JLabel jLabelNumComps;
	private javax.swing.JLabel jLabelRow;
	private javax.swing.JMenuBar jMenuBar;
	private javax.swing.JMenu jMenuEdit;
	private javax.swing.JMenu jMenuFile;
	private javax.swing.JMenu jMenuHelp;
	private javax.swing.JMenuItem jMenuItemAbout;
	private javax.swing.JMenuItem jMenuItemAbout1;
	private javax.swing.JMenuItem jMenuItemCancel;
	private javax.swing.JMenuItem jMenuItemCancel1;
	private javax.swing.JMenuItem jMenuItemCopy;
	private javax.swing.JMenuItem jMenuItemCopy1;
	private javax.swing.JMenuItem jMenuItemHelp;
	private javax.swing.JMenuItem jMenuItemHelp1;
	private javax.swing.JMenuItem jMenuItemNew;
	private javax.swing.JMenuItem jMenuItemNew1;
	private javax.swing.JMenuItem jMenuItemOK;
	private javax.swing.JMenuItem jMenuItemOK1;
	private javax.swing.JMenuItem jMenuItemOpen;
	private javax.swing.JMenuItem jMenuItemOpen1;
	private javax.swing.JMenuItem jMenuItemPaste;
	private javax.swing.JMenuItem jMenuItemPaste1;
	private javax.swing.JMenuItem jMenuItemPrint;
	private javax.swing.JMenuItem jMenuItemPrint1;
	private javax.swing.JMenuItem jMenuItemRedo;
	private javax.swing.JMenuItem jMenuItemRedo1;
	private javax.swing.JMenuItem jMenuItemSave;
	private javax.swing.JMenuItem jMenuItemSave1;
	private javax.swing.JMenuItem jMenuItemSaveAs;
	private javax.swing.JMenuItem jMenuItemSaveAs1;
	private javax.swing.JMenuItem jMenuItemUndo;
	private javax.swing.JMenuItem jMenuItemUndo1;
	private javax.swing.JPanel jPanelContainer;
	private javax.swing.JPanel jPanelIndicators;
	private javax.swing.JPanel jPanelRowCol;
	private javax.swing.JPopupMenu jPopupMenu1;
	private javax.swing.JScrollPane jScrollPaneContainer;
	private javax.swing.JSeparator jSeparator1;
	private javax.swing.JSeparator jSeparator11;
	private javax.swing.JSeparator jSeparator3;
	private javax.swing.JSeparator jSeparator31;
	private javax.swing.JSeparator jSeparator311;
	private javax.swing.JSeparator jSeparator312;
	private javax.swing.JSeparator jSeparator4;
	private javax.swing.JSeparator jSeparator41;
	private javax.swing.JToggleButton jToggleButtonAtribui;
	private javax.swing.JToggleButton jToggleButtonCB;
	private javax.swing.JToggleButton jToggleButtonCBAL;
	private javax.swing.JToggleButton jToggleButtonCNI;
	private javax.swing.JToggleButton jToggleButtonCNIAL;
	private javax.swing.JToggleButton jToggleButtonDireita;
	private javax.swing.JToggleButton jToggleButtonEsquerda;
	private javax.swing.JToggleButton jToggleButtonFrente;
	private javax.swing.JToggleButton jToggleButtonIVPWM;
	private javax.swing.JToggleButton jToggleButtonIncDec;
	private javax.swing.JToggleButton jToggleButtonMarchAtras;
	private javax.swing.JToggleButton jToggleButtonPWM;
	private javax.swing.JToggleButton jToggleButtonSetReset;
	private javax.swing.JToolBar jToolBarMain;
	private javax.swing.JToolBar jToolBarOKCancel;
	private javax.swing.JToolBar jToolBarP1;
	private javax.swing.JToolBar jToolBarP2;
	private javax.swing.JToolBar jToolBarP3;
	private javax.swing.JToolBar jToolBarP4;
	// End of variables declaration//GEN-END:variables
	// My variables declaration
	private int row = 1;
	private int column = 1;
	private int maxRow = 1;
	private int maxColumn = 1;
	private final int COL_WIDTH = 77;
	private final int COL_HEIGHT = 45;
	private final int MAX_COLUMNS = 1000;
	private final int MAX_ROWS = 1000;
	private int colToCopyIni;
	private int rowToCopyIni;
	private int colToCopyEnd;
	private int rowToCopyEnd;
	private int rowToPaste;
	private int colToPaste;
	private int counter;
	private int counter2 = 0;
	private int iValuesSize = 0;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelAtribui modelAtribui;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompAndBin modelCompAndBin;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompAndInt modelCompAndInt;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompBin modelCompBin;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelCompInt modelCompInt;
	private static pt.utl.ist.elab.client.webrobot.customizer.Models.ModelConfInOut modelConfInOut = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelConfInOut();
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelDireita modelDireita;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelEsquerda modelEsquerda;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelFrente modelFrente;
	private static pt.utl.ist.elab.client.webrobot.customizer.Models.ModelIVPWM modelIVPWM = new pt.utl.ist.elab.client.webrobot.customizer.Models.ModelIVPWM();
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelIncDec modelIncDec;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelMarchAtras modelMarchAtras;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelPWM modelPWM;
	private pt.utl.ist.elab.client.webrobot.customizer.Models.ModelSetReset modelSetReset;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.CompInt compInt;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.CompBin compBin;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.CompAndInt compAndInt;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.CompAndBin compAndBin;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Atribui atribui;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.IncDec incDec;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.SetReset setReset;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.PWM pwm;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.IVPWM ivpwm = new pt.utl.ist.elab.client.webrobot.customizer.Comps.IVPWM(
			JPrograf.modelIVPWM);
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Frente frente;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.MarchAtras marchAtras;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Direita direita;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Esquerda esquerda;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.HorLine horLine;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.ConfInOut confInOut = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.ConfInOut(
			JPrograf.jFrameDummy, true, JPrograf.modelConfInOut);
	private final pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.EditSubDel editSubDel = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.EditSubDel(
			JPrograf.jFrameDummy, true);
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.IntroMethod introMethod;
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.SubBlock subBlock;
	private final javax.swing.JButton jButtonProgStart;
	private boolean endedRowCol = false;
	private boolean isFileValid = true;
	private boolean haveBeenChanges = false;
	private final boolean hasFileChanged = true;
	private final boolean paintTop = false;
	private final boolean isThereAnotherCompDown = false;
	private boolean addDireita = false;
	private boolean addEsquerda = false;
	private boolean addPasteDireita = false;
	private boolean addPasteEsquerda = false;
	private boolean actionCanceled = false;
	private boolean shiftedColsInDel = false;
	private final pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] matrix = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[MAX_ROWS][MAX_COLUMNS];
	private final String[][] matrixWiring = new String[MAX_ROWS][MAX_COLUMNS];
	private static Undo undoBlock;
	private static Undo undoWiring;
	private final javax.swing.ImageIcon iconPrograf = new javax.swing.ImageIcon(getClass().getResource(
			"/pt/utl/ist/elab/client/webrobot/customizer/Icons/JPrograf.gif"));
	private final pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.ConfCopy confCopy = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.ConfCopy(
			JPrograf.jFrameDummy, true);
	private final pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.ConfPaste confPaste = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Configs.ConfPaste(
			JPrograf.jFrameDummy, true);
	private final CopyPaste copyPaste = new CopyPaste();
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] matrixToCopy = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[3][3];// Security
	// initialization
	private String[][] matrixWiringToCopy = new String[3][3];// Security
	// initialization
	private pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[][] matrixPaste = new pt.utl.ist.elab.client.webrobot.customizer.Comps.Block[3][3];// Security
	// initialization
	private String[][] matrixWiringPaste = new String[3][3];// Security
	// initialization
	private final ExtensionFilter prografExtension = new ExtensionFilter("grf", "ext");
	private String extension = "";
	private Object iValues[][];
	private final Object[] YES_NO_OPTS = { "Sim", "N�o" };
	private final Object[] YES_NO_CANCEL_OPTS = { "Sim", "N�o", "Cancelar" };
	private java.io.File saveFile = null;
	private static String TITLE_VERSION = "JPrograf 1.1.2";
	private static javax.swing.JFrame jFrameDummy;

	/** Holds value of property runStandAloneApp. */
	private boolean runStandAloneApp = false;

	/** Help variables */
	private final String helpURL = ReCResourceBundle.findStringOrDefault("webrobot$rec.exp.url.webrobot.3",
			"http://www.e-escola.pt/site-bin/licao_frame.asp?tema_id=43&mat_id=82&dif_id=1");

	/*
	 * private javax.help.HelpSet hs; private javax.help.HelpBroker hb;
	 */
}
